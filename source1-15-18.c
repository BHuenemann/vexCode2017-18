#pragma config(Sensor, in1,    clawPot,        sensorPotentiometer)
#pragma config(Sensor, in2,    mgPot,          sensorPotentiometer)
#pragma config(Sensor, in3,    liftPot,        sensorPotentiometer)
#pragma config(Sensor, in4,    yaw,            sensorNone)
#pragma config(Sensor, dgtl1,  rightEn,        sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  leftEn,         sensorQuadEncoder)
#pragma config(Sensor, dgtl11, LCD,            sensorNone)
#pragma config(Motor,  port1,           rLift,         tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           lLiftMG,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           rLiftMG,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           lLift,         tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           fL,            tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           fR,            tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           bL,            tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           bR,            tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           lClaw,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          rClaw,         tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX2)

#pragma competitionControl(Competition)

#include "Vex_Competition_Includes.c"

//#include "resources\tunes.h"

//Right mobile goal lift is in port 1
//Left mobile goal lift is in port 2
//Right lift motor is in port 3
//Left lift motor is in port 4
//Right claw motor is in port 5
//Left claw motor is in port 6
//Front right drive is in port 7
//Back right drive is in port 8
//Front left drive is in port 9
//Back left drive is in port 10



/******************************************************************
/*
/*											 USER CONSTANTS
/*
*******************************************************************/



const unsigned int STACK_HEIGHT = 42;			//Height for lift to raise with each cone stack
const unsigned int BASE_HEIGHT = 350;			//Height for lift with a mobile goal

const unsigned int WHEEL_TO_CENTER_WIDTH = 12;	//Width from average x-location of wheels to the center of the robot

const unsigned int THRESHOLD = 35;			//Threshold for motors to work
const unsigned int CLAW_TOL = 20;				//Claw tolerance for p-tuning
const unsigned int LIFT_MG_TOL = 20;		//Mobile goal lift tolerance for p-tuning
const unsigned int LIFT_TOL = 30;				//Lift tolerance for p-tuning
const unsigned int GIVE_UP_TIME = 5000;	//Time to give functions before it gives up on it's target

const unsigned int CLAW_ACC_TOL = 50;		//The thousandths accuracy of the claw
const unsigned int LIFT_MG_ACC_TOL = 50;//The thousandths accuracy of the mobile goal lift
const unsigned int LIFT_ACC_TOL = 50;		//The thousandths accuracy of the lift

const unsigned int CLAW_MAX = 2295;			//The maximum for the claw potentiometer
const unsigned int CLAW_MIN = 815;			//The minimum for the claw potentiometer

const unsigned int LIFT_MG_MAX = 3330;	//The maximum for the left mobile goal lift potentiometer (lift deployed)
const unsigned int LIFT_MG_MIN = 730;		//The minimum for the left mobile goal lift potentiometer (lift undeployed)

const unsigned int LIFT_MAX = 3180;			//The maximum for the left lift potentiometer
const unsigned int LIFT_MIN = 1360;			//The minimum for the left lift potentiometer

const float P_CLAW = 0.3;								//The p-value for the claw's movement
const float P_LIFT_MG = 0.3;						//The p-value for the mobile goal lift's movement
const float P_LIFT = 0.3;								//The p-value for the lift's movement (proportional)
const float I_LIFT = 0;									//The i-value for the lift's movement (integral)
const float D_LIFT = 0;									//The d-value for the lift's movement (derivative)



//Enumerated type used for targets array in autonomous
enum targetTypes {
	CLAW				= 0,
	LIFT_MG			= 1,
	LIFT				= 2,
	N_TARGETS		= 3
};

//Global variables used for stack count
int stackCountG = 0;								//Variable to count the amount of cones stacked
//Global variables for toggle switches
bool skillsToggleStateG = false;		//Variable to check if skills is toggled
bool skillsPressedG = false;				//Variable to check if the skills button is pressed
bool fieldSideToggleStateG = false;	//Variable to check which field side the robot is on
bool fieldSidePressedG = false;			//Variable to check if the field side button is pressed



/******************************************************************
/*
/*											 FUNCTIONS
/*
*******************************************************************/



/* A generic conversion function for converting from a thousandths to
*  a potentiometer value for either the mobile goal lift or left/right
*  lift */
float thousandthsToPot(targetTypes type, int thousandths) {
	//Stores desired extrema as floats to avoid later unit conversions
	float max = (type == LIFT_MG) ? LIFT_MG_MAX :
	((type == CLAW) ? CLAW_MAX : LIFT_MAX);
	float min = (type == LIFT_MG) ? LIFT_MG_MIN :
	((type == CLAW) ? CLAW_MIN : LIFT_MIN);

	//Performs the calcualations and returns the desired value
	return (min + (max - min) * ((float)thousandths / 1000));
}

/* A generic conversion function for converting from a side of a
*  system that uses a potentiometer to a thousandths of a
*  potentiometer value */
float potToThousandths(targetTypes type) {
	//Stores desired extrema as floats to avoid later unit conversions
	float max = (type == LIFT_MG) ? LIFT_MG_MAX :
	((type == CLAW) ? CLAW_MAX : LIFT_MAX);
	float min = (type == LIFT_MG) ? LIFT_MG_MIN :
	((type == CLAW) ? CLAW_MIN : LIFT_MIN);
	//Stores the current potentiometer value
	float potVal = (type == LIFT_MG) ? SensorValue[mgPot] :
	((type == CLAW) ? SensorValue[clawPot] : SensorValue[liftPot]);

	//Performs the calculations and returns the desired value
	return 1000 * ((potVal - min) / (max - min));
}

/* Basic conversion for converting inches driven to encoder ticks
*  that can be used for p-tuning */
float inchesToEncoderTicks(float inches) {
	float encoderTicks = 90 * PI * inches;
	return encoderTicks;
}

/* P-tunes the claw to a specified mobile goal lift target,
*  which is a thousandths value along the range of the claw.
*  This version of the function is used during autonomous in
*  conjunction with an array */
void pTuneClaw(int clawTarget) {
	//The mobile goal target is corrected if it is above the maximum
	if(clawTarget > 1000)
		clawTarget = 1000;
	//The mobile goal target is corrected if it is below the minimum
	else if(clawTarget < 0)
		clawTarget = 0;

	//Finds the error mutplied by the p-value of the mobile goal lift
	int clawError = P_CLAW * (thousandthsToPot(CLAW, clawTarget) - SensorValue[clawPot]);

	//The mobile goal lift only p-tunes if the error is above the tolerance
	motor[lClaw] = motor[rClaw] = (abs(clawError) >= CLAW_TOL) ? clawError : 0;
}

/* SEE void pTuneClaw(int clawTarget)
*  The equivalent of the above function, but the target is passed by
*  reference rather than by value. This version of the function is
*  used during driver mode in conjunction with a local variable */
void pTuneClaw(int* clawTarget) {
	if(*clawTarget > 1000)
		*clawTarget = 1000;
	else if(*clawTarget < 0)
		*clawTarget = 0;

	int clawError = P_CLAW * (thousandthsToPot(CLAW, *clawTarget) - SensorValue[clawPot]);

	motor[lClaw] = motor[rClaw] = (abs(clawError) >= CLAW_TOL) ? clawError : 0;
}

/* P-tunes the mobile goal lift to a specified mobile goal lift
*  target, which is a thousandths value along the range of the
*  claw. This version of the function is used during autonomous
*  in conjunction with an array */
void pTuneMGLift(int liftMGTarget) {
	//The mobile goal target is corrected if it is above the maximum
	if(liftMGTarget > 1000)
		liftMGTarget = 1000;
	//The mobile goal target is corrected if it is below the minimum
	else if(liftMGTarget < 0)
		liftMGTarget = 0;

	//Finds the error mutplied by the p-value of the mobile goal lift
	int liftMGError = P_LIFT_MG * (thousandthsToPot(LIFT_MG, liftMGTarget) - SensorValue[mgPot]);

	//The mobile goal lift only p-tunes if the error is above the tolerance
	motor[lLiftMG] = motor[rLiftMG] = (abs(liftMGError) >= LIFT_MG_TOL) ? liftMGError : 0;
}

/* SEE void pTuneMGLift(int liftMGTarget)
*  The equivalent of the above function, but the target is passed by
*  reference rather than by value. This version of the function is
*  used during driver mode in conjunction with a local variable */
void pTuneMGLift(int* liftMGTarget) {
	if(*liftMGTarget > 1000)
		*liftMGTarget = 1000;
	else if(*liftMGTarget < 0)
		*liftMGTarget = 0;

	int liftMGError = P_LIFT_MG * (thousandthsToPot(LIFT_MG, *liftMGTarget) - SensorValue[mgPot]);

	motor[lLiftMG] = motor[rLiftMG] = (abs(liftMGError) >= LIFT_MG_TOL) ? liftMGError : 0;
}

/* P-tunes the lift to a specified lift target, which is a
*  thousandths value along the range of the lift.
*  This version of the function is used during autonomous
*  in conjunction with an array */
void pTuneLift(int liftTarget) {
	if(liftTarget > 1000)
		liftTarget = 1000;
	else if(liftTarget < 0)
		liftTarget = 0;

	int error = P_LIFT * thousandthsToPot(LIFT, liftTarget) - SensorValue[liftPot];

	motor[lLift] = motor[rLift] = ((abs(error) >= LIFT_TOL) && (abs(error) > 20)) ? error : 0;
}

/* PID version of the previous function that is used for user control
*  and is passed by reference than by value.
*  This function is used during driver mode in conjunction with local
*  variables */
void pidTuneLift(int* liftTarget, int* integral, int* prevError) {
	if(*liftTarget > 1000)
		*liftTarget = 1000;
	else if(*liftTarget < 0)
		*liftTarget = 0;

	//Finds the error between the target and the actual value
	int error = thousandthsToPot(LIFT, *liftTarget) - SensorValue[liftPot];
	//Continuously adds the error to the integral count
	*integral += error;
	//Keeps track of the difference between the error and the previous error
	int derivative = error - *prevError;
	//Resets the previous error
	*prevError = error;

	//Sets the drive values equal to their respective variable multiplied by the tuning value
	int drive = (P_LIFT * error) + (I_LIFT * (*integral)) + (D_LIFT * derivative);

	//Resets the integral if the drive isn't PID tuning
	if(abs(error) < LIFT_TOL || (abs(drive) > 20)) {
		*integral = 0;
	}

	//Doesn't move the motors if they are too small or it's within the tolerance to reduce motor whine
	motor[lLift] = motor[rLift] = ((abs(error) >= LIFT_TOL) && (abs(drive) > 30)) ? drive : 0;
}

/* The robot drives a set distance in encoder ticks, given by
*  enTarget. It uses a formula to drive at a speed scaled to
*  the difference between the current displacement and the
*  final displacement.  It then drives backwards to counteract
*  any additional drift.  It p-tunes while doing so */
void waitDistance(const int* const targets, int enTarget) {
	enTarget = inchesToEncoderTicks(enTarget);

	SensorValue[rightEn] = 0;		//Encoders zeroed
	SensorValue[leftEn] = 0;
	clearTimer(T1);							//Timer is cleared to make it give up if it takes too long

	int drive = 0;							//Variable for storing the speed the drive should travel at

	int a = 18;									//Variable that reduces drift when increased but also lowers speed

	/* The robot uses a formula to scale speed to position if
	*  the velocity would be within the threshold to start
	*  driving, but otherwise sets the speed equal to the
	*  minimum threshold otherwise */
	while(abs(SensorValue[leftEn]) < abs(enTarget) && time1[T1] < GIVE_UP_TIME) {
		drive = sgn(enTarget) * (a * log(-abs(SensorValue[leftEn]) + abs(enTarget)) + (127 - (a * log(abs(enTarget)))));
		if(sgn(enTarget) > 0 && drive < THRESHOLD) {
			drive = THRESHOLD;
		}
		else if(sgn(enTarget) < 0 && drive > -THRESHOLD) {
			drive = -THRESHOLD;
		}
		motor[bR] = motor[fR] = motor[bL] = motor[fL] = drive;
		pTuneMGLift(targets[LIFT_MG]);		//P-tunes the claw and the lifts while driving
		pTuneLift(targets[LIFT]);
	}

	//Motors drive backward briefly in order to counteract additional drift
	motor[bR] = motor[fR] = motor[bL] = motor[fL] = -sgn(enTarget) * THRESHOLD;
	wait1Msec(110);
	motor[bR] = motor[fR] = motor[bL] = motor[fL] = 0;
}

/* A function used in autonomous that tells the robot to rotate a
*  certain amount in tenths of a degree, using the VEX gyro */
void waitRotate(const int* const targets, int degrees10) {
	//Multiplies the limit switch for the fieldside by the degrees, so that it is on the left side if the toggle variable is false
	degrees10 *= ((fieldSideToggleStateG) ? 1 : -1);
	SensorValue[yaw] = 0;				//Encoders zeroed
	clearTimer(T1);							//Timer is cleared to make it give up if it takes too long

	int drive = 0;							//Variable that contains the drive speed

	int a = 15;									//The intensity of the drive functoin

	/* Enacts the rotation to a set tenths of a degree (degrees10)
	*  while tuning both lifts. The rotation speed is tuned to
	*  decrease on a slope from 127 to the treshold. If it is past
	*  the threshold, it is set equal to the treshold, but with each
	*  side rotating in a different direction */
	if(degrees10 > 0) {
		while(SensorValue[yaw] < degrees10 && time1(T1) < GIVE_UP_TIME) {
			drive = sgn(degrees10) * (a * log(-abs(SensorValue[yaw]) + abs(degrees10)) + (90 - (a * log(abs(degrees10)))));
			if(abs(drive) > 90) {
				drive = sgn(degrees10) * 90;
			}
			else if(sgn(degrees10) > 0 && drive < THRESHOLD) {
				drive = THRESHOLD;
			}
			else if(sgn(degrees10) < 0 && drive > -THRESHOLD) {
				drive = -THRESHOLD;
			}
			motor[bR] = motor[fR] = drive;		//The right side moves forwards
			motor[bL] = motor[fL] = -drive;		//The left side moves backwards
			pTuneMGLift(targets[LIFT_MG]);		//P-tunes the claws and the lift while rotating
			pTuneLift(targets[LIFT]);
		}
	}
	else {
		while(SensorValue[yaw] > degrees10) {
			drive = sgn(degrees10) * (a * log(-abs(SensorValue[yaw]) + abs(degrees10)) + (90 - (a * log(abs(degrees10)))));
			if(abs(drive) > 90) {
				drive = sgn(degrees10) * 90;
			}
			else if(sgn(degrees10) > 0 && drive < THRESHOLD) {
				drive = THRESHOLD;
			}
			else if(sgn(degrees10) < 0 && drive > -THRESHOLD) {
				drive = -THRESHOLD;
			}
			motor[bR] = motor[fR] = drive;		//The right side moves forwards
			motor[bL] = motor[fL] = -drive;		//The left side moves backwards
			pTuneMGLift(targets[LIFT_MG]);		//P-tunes the claws and the lift while rotating
			pTuneLift(targets[LIFT]);
		}
	}
	//Turns off the drive motors when the rotation is complete
	motor[bR] = motor[fR] = -sgn(degrees10) * THRESHOLD;
	motor[bL] = motor[fL] = sgn(degrees10) * THRESHOLD;
	wait1Msec(110);
	motor[bR]  = motor[fR] = motor[bL] = motor[fL] = 0;
}

/* A function used in autonomous that tells the robot to move in a
*  curved path to a new coordinate that's outTargetX feet away
*  horizontally and outTargetY feet away vertically and the plane
*  is oriented depending on the rotation of the robot. It also has
*  the option to move backwards in a curved motion. The first part
*  of this function calculates the values that it will use and the
*  second part implements them */
void waitDistanceCurve(const int* const targets, int outTargetX, int outTargetY, bool backwards = false) {
	//Sets up a variable in so that it can easily flip the direction if commanded to go backwards
	int direction = (backwards) ? -1 : 1;

	//Sets a new location depending on if the robot is supposed to go left or right
	int location = sgn(outTargetX) * WHEEL_TO_CENTER_WIDTH;

	//Sets up targets for the wheels on the inner side of the curve and gives them default values
	int inTargetX = 0;
	int inTargetY = outTargetY;

	/* Sets up a variable for the portion of the circle being
	*  calculated between the two points. To calculate it, the
	*  distance formula, arcsine, and the fact that all angles in
	*  a triangle add up to 180 are used. This also makes sure
	*  that the target coordinates aren't equal to values that
	*  would result in the function dividing by zero. If it's
	*  ordered to go backwards, the input value of outTargetY is
	*  flipped so that it still calculates it as if it were going
	*  forward */
	float theta = (outTargetX == - 2 * location && !outTargetY) ? 0 :
	180 - 2 * radiansToDegrees(asin((direction * outTargetY) / sqrt(((outTargetX + 2 * location) ^ 2) + ((outTargetY) ^ 2))));

	/* Calculates and sets the inner wheel targets using
	*  trigonometry. The value also depends on the direction
	*  that the robot is traveling */
	if(outTargetX > 0) {
		inTargetX = outTargetX + 2 * location * cosDegrees(theta);
		inTargetY = outTargetY - 2 * location * sinDegrees(theta);
	}
	else if(outTargetX < 0) {
		inTargetX = outTargetX + 2 * location * cosDegrees(theta);
		inTargetY = outTargetY + 2 * location * sinDegrees(theta);
	}

	/* Calculates the radios of the circle each path finds
	*  using the law of sines and makes sure that that it
	*  doesn't divide by zero */
	int outRadius = (theta) ? abs(outTargetX / (sin(theta))) : 0;
	int inRadius = (theta) ? abs(inTargetX / (sin(theta))) : 0;

	/* Calculates the distance it has to travels using the
	*  equation for the circumference of the circle dividing
	*  it by the potion of the circle being traveled in order
	*  to give each encoder a target value. It also converts
	*  the answer into encoder ticks so that it won't round the
	*  variable very much considering that it's an integer */
	int outDistance = inchesToEncoderTicks(2 * PI * outRadius * (theta / 360));
	int inDistance = inchesToEncoderTicks(2 * PI * inRadius * (theta / 360));

	/* Calculates the ratio between the target distances for the
	*  encoders so that it can multiply the inner motors by this
	*  speed. This will make sure that each side takes the same
	*  amount of time to cover their target distances. It also
	*  makes sure that it doesn't divide by zero */
	int speedRatio = (outDistance) ? inDistance / outDistance : 0;

	SensorValue[rightEn] = 0;	//Encoders zeroed
	SensorValue[leftEn] = 0;
	clearTimer(T1);						//Timer is cleared to make it give up if it takes too long

	int lDrive = 0;						//Variables for storing the speed the drives should travel at
	int rDrive = 0;

	int a = 18;								//Variable that reduces drift when increased but also lowers speed

	/* If the target involves turning right, the left encoder's
	*  target is the outer distnace and the inner encoder's target
	*  is the inner distance. The values are multiplied by the
	*  direction so that they flip if the robot is ordered to move
	*  backwards. It uses the same logarithmic tuner as the
	*  previous two functions and sets the motors equal to the
	*  threshold if the fall below the threshold. It then multiplies
	*  the right motor speed by the speed ratio since that's on the
	*  inner side so it'll have to move slower. It also p-tunes both
	*  lifts while moving. */
	if(outTargetX > 0) {
		while(SensorValue[leftEn] < outDistance && SensorValue[rightEn] < inDistance && time1[T1] < GIVE_UP_TIME) {
			lDrive = direction * a * log(-abs(SensorValue[leftEn]) + outDistance) + (127 - (a * log(outDistance)));
			rDrive = direction * a * log(-abs(SensorValue[rightEn]) + inDistance) + (127 - (a * log(inDistance)));
			if(lDrive < THRESHOLD)
				lDrive = direction * THRESHOLD;
			else if(rDrive < THRESHOLD)
				rDrive = direction * THRESHOLD;
			motor[bR] = motor[fR] = speedRatio * rDrive;
			motor[bL] = motor[fL] = lDrive;
			pTuneMGLift(targets[LIFT_MG]);
			pTuneLift(targets[LIFT]);
		}
	}
	/* If the target involves turning left, the encoder sides are
	*  set to the opposite configuration. This has the same commands
	*  but it accounds for the inner distance being on the left. */
	else if(outTargetX < 0) {
		while(SensorValue[leftEn] < inDistance && SensorValue[rightEn] < outDistance && time1[T1] < 5000) {
			lDrive = direction * a * log(-abs(SensorValue[leftEn]) + inDistance) + (127 - (a * log(inDistance)));
			rDrive = direction * a * log(-abs(SensorValue[rightEn]) + outDistance) + (127 - (a * log(outDistance)));
			if(lDrive < THRESHOLD)
				lDrive = direction * THRESHOLD;
			else if(rDrive < THRESHOLD)
				rDrive = direction * THRESHOLD;
			motor[bR] = motor[fR] = rDrive;
			motor[bL] = motor[fL] = speedRatio * lDrive;
			pTuneMGLift(targets[LIFT_MG]);
			pTuneLift(targets[LIFT]);
		}
	}

	//Motors drive backward briefly in order to counteract additional drift
	motor[bR] = motor[fR] = motor[bL] = motor[fL] = -direction * THRESHOLD;
	wait1Msec(110);
	motor[bR] = motor[fR] = motor[bL] = motor[fL] = 0;
}

/* A somewhat general function used in autonomous that changes the
*  contents of the current target values for the lifts and claw,
*  and then pTunes both the lifts and claw with their new target
*  values */
void waitActions(int* targets, int liftMGTarget, int clawTarget, int liftTarget) {
	//Assigns the contents of targets to the new lift and claw target values
	targets[CLAW] = clawTarget;
	targets[LIFT_MG] = liftMGTarget;
	targets[LIFT] = liftTarget;
	//P-tunes the lifts and the claw
	pTuneClaw(targets[CLAW]);
	pTuneMGLift(targets[LIFT_MG]);
	pTuneLift(targets[LIFT]);
}

/* Sets targets equal to the new values, then continues to test to see
*  if the claw is within the range specified by tolerance, which is
*  defined by the user or set equal to the default tolerance */
void testClaw(int* targets, int liftMGTarget, int clawTarget, int liftTarget, int accuracy = CLAW_ACC_TOL) {
	do {
		waitActions(targets, liftMGTarget, clawTarget, liftTarget);
	} while(potToThousandths(CLAW) < clawTarget - accuracy || potToThousandths(CLAW) > clawTarget + accuracy);
}

/* Specific function for p-tuning just the claw */
void setClaw(int* targets, int clawTarget, int accuracy = CLAW_ACC_TOL) {
	testClaw(targets, targets[LIFT_MG], clawTarget, targets[LIFT], accuracy);
}

/* Sets targets equal to the new values, then continues to test to see
*  if the mobile goal lift is within the range specified by tolerance,
*  which is defined by the user or set equal to the default
*  tolerance */
void testMGLift(int* targets, int liftMGTarget, int clawTarget, int liftTarget, int accuracy = LIFT_MG_ACC_TOL) {
	do {
		waitActions(targets, liftMGTarget, clawTarget, liftTarget);
	} while(potToThousandths(LIFT_MG) < liftMGTarget - accuracy || potToThousandths(LIFT_MG) > liftMGTarget + accuracy);
}

/* Specific function for p-tuning just the mobile goal lift */
void setMGLift(int* targets, int liftMGTarget, int accuracy = LIFT_MG_ACC_TOL) {
	testMGLift(targets, liftMGTarget, targets[CLAW], targets[LIFT], accuracy);
}

/* Sets targets equal to the new values, then continues to test to see
*  if the lift is within the range specified by tolerance, which is
*  defined by the user or set equal to the default tolerance */
void testLift(int* targets, int liftMGTarget, int clawTarget, int liftTarget, int accuracy = LIFT_ACC_TOL) {
	do {
		waitActions(targets, liftMGTarget, clawTarget, liftTarget);
	} while(potToThousandths(LIFT) < liftTarget - accuracy || potToThousandths(LIFT) > liftTarget + accuracy);
}

/* Specific function for p-tuning just the lift */
void setLift(int* targets, int liftTarget, int accuracy = LIFT_ACC_TOL) {
	testLift(targets, targets[LIFT_MG], targets[CLAW], liftTarget, accuracy);
}

/* Function for resetting the stackcount */
void stackReset() {
	int* stackCountL = &stackCountG;		//Setup local variable based on the global variable
	*stackCountL = 0;
}

/* Function for auto stacking a cone */
void stackCone(int* targets) {

	int* stackCountL = &stackCountG;		//Setup a local variable and increment it by one
	*stackCountL++;
	int currentStackHeight = *stackCountL * STACK_HEIGHT;			//Create a variable for the current height of the cone stack

	setLift(targets, 0);																			//Lowers the lift to grab the cone
	wait1Msec(.5);
	setLift(targets, BASE_HEIGHT + 400 + currentStackHeight);	//Raises the lift to the right height
	setClaw(targets, 200);																		//Rotates the claw downwards
	setLift(targets, BASE_HEIGHT + currentStackHeight);				//Lowers the cone onto the mobile goal
	wait1Msec(.5);
	setLift(targets, BASE_HEIGHT + 400 + currentStackHeight);	//Raises the lift again
	setClaw(targets, 1000);																		//Rotates the claw forwards
	setLift(targets, 0);																			//Lowers the lift

	playTone(1050, 50);																				//Plays a tone when finished
}

/* Eliminates motor whine on the drive during user control */
int axesFix(int remote) {
	if(abs(remote) >= THRESHOLD) 		//Returns 0 if the value does not pass the TRESHOLD constant
		return remote;
	else
		return 0;
}



/******************************************************************
/*
/*											 TASKS
/*
*******************************************************************/



//Task for displaying the battery on the LCD Screen
task displayBattery()
{
	bool toggleSwitch = false;					//Toggle switch variable
	string mainBattery, backupBattery;	//Setup two strings
	while(1) {
		//Toggle switch code for turning on and off
		if(nLCDButtons) {
			toggleSwitch = !toggleSwitch;
			wait1Msec(500);
		}
		if(toggleSwitch) {
			bLCDBacklight = true;     		 	//Turn on LCD Backlight
			clearLCDLine(0);         		   	//Clear line 1 of the LCD
			clearLCDLine(1);          		 	//Clear line 2 of the LCD

			//Display the Primary Robot battery voltage
			displayLCDString(0, 0, "Primary: ");
			sprintf(mainBattery, "%1.2f%c", nImmediateBatteryLevel/1000.0,'V'); //Build the value to be displayed
			displayNextLCDString(mainBattery);

			//Display the Backup battery voltage
			displayLCDString(1, 0, "Backup: ");
			sprintf(backupBattery, "%1.2f%c", BackupBatteryLevel/1000.0, 'V');	//Build the value to be displayed
			displayNextLCDString(backupBattery);

			//Short delay for the LCD refresh rate
			wait1Msec(100);
		}
		else {
			bLCDBacklight = false;     		 	//Turn off LCD Backlight
			clearLCDLine(0);         		   	//Clear line 1 of the LCD
			clearLCDLine(1);          		 	//Clear line 2 of the LCD
		}
	}
}

task calibrateGyro()
{
	SensorType[yaw] = sensorNone;	//Resets the gyroscope
	wait1Msec(1100);							//Provides time for calibration
	SensorType[yaw] = sensorGyro;	//Reassigns the yaw gyroscope's sensor type
	wait1Msec(1100);							//Waits for the gyro to calibrate

	SensorValue[rightEn] = 0;			//Zeroes the right encoder
	SensorValue[leftEn] = 0;			//Zeroes the left encoder
	playTone(1200, 50);						//Plays a tone when calibration is finished to alert the operator
}

task displayAutonChoices()
{
	//Sets up local variables based on the global variables for toggle switches
	bool* fieldSideToggleStateL = &fieldSideToggleStateG;
	bool* fieldSidePressedL = &fieldSidePressedG;
	bool* skillsToggleStateL = &skillsToggleStateG;
	bool* skillsPressedL = &skillsPressedG;

	bLCDBacklight = true;			//Turn the backlight for the LCD On

	//Default messasges
	displayLCDString(0, 0, "Auton Settings:");
	displayLCDString(1, 0, "L      NoSk     ");

	while(1) {
		//Check for the left button being pressed if the button isn't already pressed
		if((nLCDButtons & leftBtnVEX) && !(*fieldSidePressedL)) {
			*fieldSideToggleStateL = !(*fieldSideToggleStateL);	//Change the toggle state
			*fieldSidePressedL = true;													//Note that the button is pressed
		}
		//If the left button isn't pressed
		else if (!(nLCDButtons & leftBtnVEX)) {
			*fieldSidePressedL = false;													//Note that the button is not pressed
		}

		//Same toggle switch with the skills button
		if((nLCDButtons & centerBtnVEX) && !(*skillsPressedL)) {
			*skillsToggleStateL = !(*skillsToggleStateL);
			*skillsPressedL = true;
		}
		else if (!(nLCDButtons & centerBtnVEX)) {
			*skillsPressedL = false;
		}

		//Print various messages depending on the button state
		if(*fieldSideToggleStateL)
			displayLCDString(1, 0, "R");
		else if(!(*fieldSideToggleStateL))
			displayLCDString(1, 0, "L");
		if(*skillsToggleStateL)
			displayLCDString(1, 7, "NoSk");
		else if(!(*skillsToggleStateL))
			displayLCDString(1, 7, "Sk  ");
	}
}

//Task for stacking a cone
task stackCone() {
	int* stackCountL = &stackCountG;	//Creates a local variable for the cones being stacked
	int currentStackHeight = *stackCountL * STACK_HEIGHT; //Creates a variable for the height to stack at

	//Default lift and claw target values
	int clawTarget = 200;

	/* Series of commands to get the lift to go up, claw to rotate
	*  inward, lift to go down, and claw to rotate outward again */
	clearTimer(T1);
	while((potToThousandths(CLAW) < clawTarget - CLAW_TOL || potToThousandths(CLAW) > clawTarget + CLAW_TOL) && time1[T1] < GIVE_UP_TIME) {
		pTuneClaw(clawTarget);
	}
	clearTimer(T1);
	int liftTarget = BASE_HEIGHT + currentStackHeight;
	while((potToThousandths(LIFT) < liftTarget - LIFT_TOL || potToThousandths(LIFT) > liftTarget + LIFT_TOL) && time1[T1] < GIVE_UP_TIME) {
		pTuneLift(liftTarget);
	}
	clearTimer(T1);
	clawTarget = 1000;
	while(potToThousandths(CLAW) < clawTarget - CLAW_TOL && time1[T1] < GIVE_UP_TIME) {
		pTuneClaw(clawTarget);
	}
}



/******************************************************************
/*
/*											 AUTONOMOUS CODE
/*
*******************************************************************/



void pre_auton()
{
	bStopTasksBetweenModes = false;
	startTask(calibrateGyro);
	startTask(displayAutonChoices);
}

task autonomous()
{
	/* targets is an array of integers that stores the target
	*  values for the mglift, claw, rotation, and lift */
	int targets[N_TARGETS] = {1000, 0, 0};

	// Skills Autonomous
	if(skillsToggleStateG) {
	}

	//Regular Autonomous
	else {
		setLift(targets, 500);
		setMGLift(targets, 1000);
		waitDistance(targets, 24);
		setMGLift(targets, 0);
		waitRotate(targets, 1000);
		waitDistanceCurve(targets, 24, 15);
		waitDistance(targets, 12);
		setMGLift(targets, 1000);
		waitDistance(targets, -12);
	}
}



/******************************************************************
/*
/*											 USER CONTROL
/*
*******************************************************************/



task usercontrol()
{
	//	startTask(manageMusic);				//Plays randomly-chosen music in the last seconds of a match
	stopTask(displayAutonChoices);		//Stops displaying the choices for auton
	startTask(displayBattery);				//Displays the battery voltage

	//Sets the targets equal to the current positions
	int clawTarget = potToThousandths(CLAW);
	int liftTarget = potToThousandths(LIFT);
	int mgLiftTarget = potToThousandths(LIFT_MG);

	//Variables for PID tuning
	int integral = 0;									//Integral tuning variable
	int prevError = 0;								//Derivative tuning variable

	int* stackCountL = &stackCountG;	//Creates a local variable for the cones being stacked

	bool incrementPressed = false;		//Variable for incrementing the stack count

	while (1)
	{
		//Ch2					=		Right drive
		//Ch3					=		Left drive
		//5U and 5D		=		Lift
		//6U and 6D		=		Claw
		//7L					=		Mobile goal up
		//7D					=		Mobile goal down
		//8L					=		Lift force up
		//8U					=		Stack cone
		//8D					=		Lift force down
		//8R					=		Reset count

		//Give up function
		if(vexRT[Btn5U] && vexRT[Btn5D] && vexRT[Btn8D]) {
			stopTask(stackCone);
			motor[lLift] = motor[rLift] = 0;
			liftTarget = potToThousandths(LIFT);
			clawTarget = potToThousandths(CLAW);
		}

		//Drive input:
		motor[fR] = motor[bR] = axesFix(vexRT[Ch2]);			//Sets the right motors equal to channel 2
		motor[fL] = motor[bL] = axesFix(vexRT[Ch3]);			//Sets the left motors equal to channel 3

		//Claw input:
		if(vexRT[Btn6U]) {
			motor[lClaw] = motor[rClaw] = (SensorValue[clawPot] <= CLAW_MAX) ? 127 : 0;
		}
		else if(vexRT[Btn6D]) {
			motor[lClaw] = motor[rClaw] = (SensorValue[clawPot] >= CLAW_MIN) ? -127 : 0;
		}
		else {
			motor[lClaw] = motor[rClaw] = 0;
		}

		//Lift input:
		if(vexRT[Btn8D])
			liftTarget = 500;
		else if(vexRT[Btn8L])
			liftTarget = 800;
		else if(vexRT[Btn5U] || vexRT[Btn5D]) {
			//5U and 5D shoulder buttons increment and decrement the lift target
			liftTarget += 3 * (vexRT[Btn5U] - vexRT[Btn5D]);
		}

		pidTuneLift(&liftTarget, &integral, &prevError);					//PID tunes the lift

		//Mobile goal lift input:
		if(vexRT[Btn7L] || vexRT[Btn7D])		//Raises the lift if 7L or 7d is pressed
			mgLiftTarget -= 3 * (vexRT[Btn7D] - vexRT[Btn7L]);

		pTuneMGLift(&mgLiftTarget);

		/* These buttons increment the internal stackcount and
		*  have the speaker play tunes to indicate what the
		*  stack count is. */
		if(vexRT[Btn7U] && !incrementPressed) {
			*stackCountL++;
			incrementPressed = true;
			for(int i = 0; i < *stackCountL; i++) {
				playTone(800, 100);
				wait1Msec(200);
			}
		}
		else if(vexRT[Btn7R] && !incrementPressed) {
			if(*stackCountL > 0)
				*stackCountL--;
			incrementPressed = true;
			for(int i = 0; i < *stackCountL; i++) {
				playTone(400, 100);
				wait1Msec(200);
			}
		}
		else {
			incrementPressed = false;
		}
		/* Stack function and stack reset
		*  See void stackCone(int* targets) */
		if(vexRT[Btn8U]) {
			startTask(stackCone);
			clearTimer(T2);
		}
		else if(vexRT[Btn8R]) {		//Resets the stack count if 8L is pressed
			*stackCountL = 0;
			playTone(525, 1000);
		}
		writeDebugStreamLine("current = %.3f  ", potToThousandths(LIFT));
		writeDebugStream("target = %d  ", liftTarget);
		writeDebugStream("rms = %d  ", motor[rLift]);
		writeDebugStream("lms = %d  ", motor[lLift]);
	}
}
