#pragma config(UART_Usage, UART1, uartVEXLCD, baudRate19200, IOPins, None, None)
#pragma config(Sensor, in1,    lLiftPot,       sensorNone)
#pragma config(Sensor, in2,    mgPot,          sensorPotentiometer)
#pragma config(Sensor, in3,    clawPot,        sensorPotentiometer)
#pragma config(Sensor, in4,    rLiftPot,       sensorPotentiometer)
#pragma config(Sensor, in5,    mgIn,           sensorLineFollower)
#pragma config(Sensor, in6,    yaw,            sensorNone)
#pragma config(Sensor, dgtl1,  rightEn,        sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  leftEn,         sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  Sonar,          sensorSONAR_inch)
#pragma config(Sensor, dgtl11, LCD,            sensorNone)
#pragma config(Motor,  port1,           intake,        tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           liftMG,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           claw,          tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           lLift,         tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           fL,            tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port6,           fR,            tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           bL,            tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port8,           bR,            tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port9,           rLift,         tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port10,          cL,            tmotorVex393_HBridge, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX2)

#pragma competitionControl(Competition)

#include "Vex_Competition_Includes.c"
//#include "resources\tunes.h"

//Intake is in port 1
//Mobile goal lift is in port 2
//Claw is in port 3
//Left lift is in port 4
//Front left drive is in port 5
//Front right drive is in port 6
//Back left drive drive is in port 7
//Back right drive is in port 8
//Right lift is in port 9
//Center left is in port 10



/******************************************************************
/*
/*											 USER CONSTANTS
/*
*******************************************************************/



const unsigned int STACK_HEIGHT = 300;		//Height lift should be to grab a cone
const unsigned int LOAD_HEIGHT = 500;			//Height lift should be at to stack auto loads
const unsigned int DOWN_ADD_HEIGHT = 150;	//Height the lift should subtract from the target when it stops going
const unsigned int UP_ADD_HEIGHT = 150;		//Height the lift should add to the target when it stops going up

const unsigned int SONAR_CONE = 8;				//Distance cones are normally from the sonar

const unsigned int WHEEL_TO_CENTER = 7;		//Width from average x-location of wheels to the center of the robot
const unsigned int GIVE_UP_TIME = 3000;		//Time to give functions before it gives up on it's target

const unsigned int MG_THRESHOLD = 2950;		//MGs are less than the threshold and no MGs are more
const unsigned int LIN_THRESHOLD = 12;		//Threshold for linearized motors to work
const unsigned int RELEASE_THRESHOLD = 5;	//Threshold for derivative when auto releasing cones
const unsigned int THRESHOLD = 21;				//Threshold for normal motors to work

const unsigned int SONAR_TOL = 4;					//Tolerance for the sonar sensor
const unsigned int CLAW_TOL = 30;					//Claw tolerance for PID-tuning
const unsigned int LIFT_MG_TOL = 20;			//Mobile goal lift tolerance for PID-tuning
const unsigned int LIFT_TOL = 20;					//Lift tolerance for PID-tuning

const unsigned int CLAW_ACC_TOL = 25;			//The thousandths accuracy of the claw
const unsigned int LIFT_MG_ACC_TOL = 50;	//The thousandths accuracy of the mobile goal lift
const unsigned int LIFT_ACC_TOL = 50;			//The thousandths accuracy of the lift

const unsigned int CLAW_MAX = 3490;				//The maximum for the claw potentiometer
const unsigned int CLAW_MIN = 1680;				//The minimum for the claw potentiometer

const unsigned int LIFT_MG_MAX = 3220;		//The maximum for the left mobile goal lift potentiometer (lift deployed)
const unsigned int LIFT_MG_MIN = 880;			//The minimum for the left mobile goal lift potentiometer (lift undeployed)

const unsigned int L_LIFT_MAX = 2930;			//The maximum for the left lift potentiometer
const unsigned int L_LIFT_MIN = 1410;			//The minimum for the left lift potentiometer
const unsigned int R_LIFT_MAX = 2730;			//The maximum for the right lift potentiometer
const unsigned int R_LIFT_MIN = 1280;			//The minimum for the right lift potentiometer

const float Kp_LIFT_MG = 0.05;						//PID values for tuning the lift, mobile goal lift, and claw during user control
const float Ki_LIFT_MG = 0;
const float Kd_LIFT_MG = 0.5;
const float Kp_LIFT = 0.3;
const float Ki_LIFT = 0;
const float Kd_LIFT = 5;
const float Kp_CLAW = 0.1;
const float Ki_CLAW = 0;
const float Kd_CLAW = 0;

//Array for linearizing the motors
const unsigned int trueSpeed[128] =
{
	0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
	0, 21, 21, 21, 22, 22, 22, 23, 24, 24,
	25, 25, 25, 25, 26, 27, 27, 28, 28, 28,
	28, 29, 30, 30, 30, 31, 31, 32, 32, 32,
	33, 33, 34, 34, 35, 35, 35, 36, 36, 37,
	37, 37, 37, 38, 38, 39, 39, 39, 40, 40,
	41, 41, 42, 42, 43, 44, 44, 45, 45, 46,
	46, 47, 47, 48, 48, 49, 50, 50, 51, 52,
	52, 53, 54, 55, 56, 57, 57, 58, 59, 60,
	61, 62, 63, 64, 65, 66, 67, 67, 68, 70,
	71, 72, 72, 73, 74, 76, 77, 78, 79, 79,
	80, 81, 83, 84, 84, 86, 86, 87, 87, 88,
	88, 89, 89, 90, 90,127,127,127
};



//Enumerated type used for targets array in autonomous
enum targetTypes {
	CLAW				= 0,
	LIFT_MG			= 1,
	LIFT				= 2,
	N_TARGETS		= 3
};

/* Static variables for toggle switches. The first item
*  of the array is the variable being changed and the second is
*  whether or not the condition is true. */
static int autonTypeToggle[2] = {0, 0};	//Variable to check which autonomous to run
static int fieldSideToggle[2] = {0, 0};	//Variable to check which field side the robot is on
static int autonToggle[2] = {1, 0};			//Variable to check if auton should run
static int autoStackToggle[2] = {1, 0};	//Variable to check if the robot should auto stack cones



/******************************************************************
/*
/*											 FUNCTIONS
/*
*******************************************************************/



/* This is a general function that toggles arrays between values.
*  It only resets when the condition is false which allows for
*  the variable to be toggled again. It also inputs the amount of
*  states to toggle between */
void toggleVariable(int* toggleArray, bool condition, int toggleStates = 2, bool tone = false) {
	if(condition && !(toggleArray[1])) {
		toggleArray[0] = (toggleArray[0] + 1) % toggleStates;		//Change the toggle state
		if(tone) {
			if(toggleArray[0]) { playTone(600, 50); wait1Msec(500); }
			else { playTone(400, 50); wait1Msec(500); }
		}
		toggleArray[1] = 1;																			//Note that the condition is true
	}
	else if(condition) {
		toggleArray[1] = 0;																			//Note that the condition is now not true
	}
}
/* This function bounds the input between two numbers, the minimum
*  and maximum, and returns that number. The min and max are 127
*  by default since that's the default min and max for motors */
int rectify(int motorSpeed, int min = -127, int max = 127, float ratio = 1) {
	motorSpeed = (motorSpeed > ratio * max) ? ratio * max : motorSpeed;
	motorSpeed = (motorSpeed < ratio * min) ? ratio * min : motorSpeed;
	return motorSpeed;
}

/* Function for linearizing and rectifying motors. Uses the linearization
*  array to figure out the true motor speeds. This is only used on the
*  drive */
int linMotor(int motorSpeed, int min = -127, int max = 127, float ratio = 1) {
	rectify(motorSpeed, min, max, ratio);
	motorSpeed = sgn(motorSpeed) * trueSpeed[abs(motorSpeed)];
	return motorSpeed;
}

/* Function used to make sure that motors aren't suddenly set to their
*  max speeds. Instead it ramps up the speed in smaller increments */
int rampMotor(int curSpeed, int tarSpeed, int slew = 30) {
	rectify(tarSpeed, curSpeed - slew, curSpeed + slew);
	return tarSpeed;
}

/* Sets each side of the drive to different speeds within specified
*  bounds and ratios for each side to go at */
void driveMotorsSet(int lSpeed, int rSpeed, int min = -127, int max = 127, float lRatio = 1, float rRatio = 1) {
	lSpeed = linMotor(lSpeed, min, max, lRatio);
	rSpeed = linMotor(rSpeed, min, max, rRatio);
	motor[bL] = motor[cL] = motor[fL] = rampMotor(motor[fL], lSpeed);
	motor[bR] = motor[fR] = rampMotor(motor[fR], rSpeed);
}

/* Sets each lift motor to a different speed within specified bounds
*  and ratios for each side to go at */
void liftMotorsSet(int lSpeed, int rSpeed, int min = -127, int max = 127, float lRatio = 1, float rRatio = 1) {
	lSpeed = rectify(lSpeed, min, max, lRatio);
	rSpeed = rectify(rSpeed, min, max, rRatio);
	motor[lLift] = (lSpeed > THRESHOLD) ? rampMotor(motor[lLift], lSpeed) : 0;
	motor[rLift] = (lSpeed > THRESHOLD) ? rampMotor(motor[rLift], rSpeed) : 0;
}

/* Sets the claw motors to go at a speed, bounds that speed, and applies
*  a ratio to it */
void clawMotorsSet(int speed, int min = -127, int max = 127, float ratio = 1) {
	speed = rectify(speed, min, max, ratio);
	motor[claw] = (speed > THRESHOLD) ? rampMotor(motor[claw], speed) : 0;
}

/* Sets the mobile goal lift motors to go at a speed, bounds that speed,
*  and applies a ratio to it */
void liftMGMotorsSet(int speed, int min = -127, int max = 127, float ratio = 1) {
	speed = rectify(speed, min, max, ratio);
	motor[liftMG] = (speed > THRESHOLD) ? rampMotor(motor[liftMG], speed) : 0;
}

/* Sets the intake motor to go at a speed, bounds that speed, and applies
*  a ratio to it */
void intakeMotorSet(int speed, int min = -127, int max = 127, float ratio = 1) {
	speed = rectify(speed, min, max, ratio);
	motor[intake] = (speed > THRESHOLD) ? rampMotor(motor[intake], speed) : 0;
}

/* A generic conversion function for converting from a thousandths to a potentiometer value
*  for either the mobile goal lift or left/right lift */
float thousandthsToPot(targetTypes type, int thousandths, tDirections side = right) {
	//Stores desired extrema as floats to avoid later unit conversions
	float max = (type == LIFT_MG) ? LIFT_MG_MAX :
	((type == CLAW) ? CLAW_MAX :
	((side == left) ? L_LIFT_MAX : R_LIFT_MAX));
	float min = (type == LIFT_MG) ? LIFT_MG_MIN :
	((type == CLAW) ? CLAW_MIN :
	((side == left) ? L_LIFT_MIN : R_LIFT_MIN));
	//Performs the calcualations and returns the desired value
	return (min + (max - min) * ((float)thousandths / 1000));
}

/* A generic conversion function for converting from a side of a system that uses a
*  potentiometer to a thousandths of a potentiometer value */
float potToThousandths(targetTypes type, tDirections side = left) {
	//Stores desired extrema as floats to avoid later unit conversions
	float max = (type == LIFT_MG) ? LIFT_MG_MAX :
	((type == CLAW) ? CLAW_MAX :
	((side == left) ? L_LIFT_MAX : R_LIFT_MAX));
	float min = (type == LIFT_MG) ? LIFT_MG_MIN :
	((type == CLAW) ? CLAW_MIN :
	((side == left) ? L_LIFT_MIN : R_LIFT_MIN));
	//Stores the current potentiometer value
	float potVal = (type == LIFT_MG) ? SensorValue[mgPot] :
	((type == CLAW) ? SensorValue[clawPot] :
	((side == left) ? SensorValue[lLiftPot] : SensorValue[rLiftPot]));
	//Performs the calculations and returns the desired value
	return 1000 * ((potVal - min) / (max - min));
}

/* Basic conversion for converting inches driven to encoder ticks
*  that can be used for p-tuning */
float inchesToEncoderTicks(float inches) {
	float encoderTicks = 90 * PI * inches;
	return encoderTicks;
}

/* PID-tunes the mobile goal lift to a specified mobile goal lift
*  target, which is a thousandths value along the range of the
*  claw. This version of the function is used during autonomous
*  in conjunction with an array */
void pidTuneClaw(int clawTarget) {
	//Corrects the target within the bounds
	clawTarget = (clawTarget > 1000) ? 1000 : clawTarget;
	clawTarget = (clawTarget < 0) ? 0 : clawTarget;

	//Creates static variables to keep track of
	static int integralClawA = 0;
	static int prevErrorClawA = 0;

	//Sets up the derivative, integral, and proportional part of PID-tuning
	int error = thousandthsToPot(CLAW, clawTarget) - SensorValue[clawPot];
	int derivative = error - prevErrorClawA;
	prevErrorClawA = (!time1(T2) % 1) ? error : prevErrorClawA;
	integralClawA += error;
	integralClawA = (abs(error) < CLAW_TOL) ? 0 : integralClawA;

	//Drive is calculated and claw motors are set to that speed
	int drive = (Kp_CLAW * error) + (Ki_CLAW * integralClawA) + (Kd_CLAW * derivative);
	clawMotorsSet(drive);
}

/* SEE void pidTuneClaw(int clawTarget)
*  The equivalent of the above function, but the target is passed by
*  reference rather than by value. This version of the function is
*  used during driver mode in conjunction with a local variable */
void pidTuneClaw(int* clawTarget) {
	*clawTarget = (*clawTarget > 1000) ? 1000 : *clawTarget;
	*clawTarget = (*clawTarget < 0) ? 0 : *clawTarget;

	static int integralClawD = 0;
	static int prevErrorClawD = 0;

	int error = thousandthsToPot(CLAW, *clawTarget) - SensorValue[clawPot];
	int derivative = error - prevErrorClawD;
	prevErrorClawD = (!(time1(T2) % 1)) ? error : prevErrorClawD;
	integralClawD += error;
	integralClawD = (abs(error) < CLAW_TOL) ? 0 : integralClawD;

	int drive = (Kp_CLAW * error) + (Ki_CLAW * integralClawD) + (Kd_CLAW * derivative);
	clawMotorsSet(drive);
}

/* PID-tunes the mobile goal lift to a specified mobile goal lift
*  target, which is a thousandths value along the range of the
*  claw. This version of the function is used during autonomous
*  in conjunction with an array */
void pidTuneLiftMG(int liftMGTarget) {
	//The mobile goal target is corrected if it's outside the bounds
	liftMGTarget = (liftMGTarget > 1000) ? 1000 : liftMGTarget;
	liftMGTarget = (liftMGTarget < 0) ? 0 : liftMGTarget;

	//Creates static variables
	static int integralLiftMGA = 0;
	static int prevErrorLiftMGA = 0;

	//Sets up the proportional, integral, and derivative parts of the PID-tuning
	int error = thousandthsToPot(LIFT_MG, liftMGTarget) - SensorValue[mgPot];
	int derivative = error - prevErrorLiftMGA;
	prevErrorLiftMGA = (!(time1(T2) % 1)) ? error : prevErrorLiftMGA;
	integralLiftMGA += error;
	integralLiftMGA = (abs(error) < LIFT_MG_TOL) ? 0 : integralLiftMGA;

	//Drive is calculated and mobile goal motors are set to that speed
	int drive = (Kp_LIFT_MG * error) + (Ki_LIFT_MG * integralLiftMGA) + (Kd_LIFT_MG * derivative);
	liftMGMotorsSet(drive);
}

/* SEE void pidTuneLiftMG(int liftMGTarget)
*  The equivalent of the above function, but the target is passed by
*  reference rather than by value. This version of the function is
*  used during driver mode in conjunction with a local variable */
void pidTuneLiftMG(int* liftMGTarget) {
	*liftMGTarget = (*liftMGTarget > 1000) ? 1000 : *liftMGTarget;
	*liftMGTarget = (*liftMGTarget < 0) ? 0 : *liftMGTarget;

	static int integralLiftMGD = 0;
	static int prevErrorLiftMGD = 0;

	int error = thousandthsToPot(LIFT_MG, *liftMGTarget) - SensorValue[mgPot];
	int derivative = error - prevErrorLiftMGD;
	prevErrorLiftMGD = (!(time1(T2) % 1)) ? error : prevErrorLiftMGD;
	integralLiftMGD += error;
	integralLiftMGD = (abs(error) < LIFT_MG_TOL) ? 0 : integralLiftMGD;

	int drive = (Kp_LIFT_MG * error) + (Ki_LIFT_MG * integralLiftMGD) + (Kd_LIFT_MG * derivative);
	liftMGMotorsSet(drive);
}

/* PID-tunes the lift to a specified lift target, which is a
*  thousandths value along the range of the lift.
*  This version of the function is used during autonomous
*  in conjunction with an array */
void pidTuneLift(int liftTarget) {
	//Bounds the lift target
	liftTarget = (liftTarget > 1000) ? 1000 : liftTarget;
	liftTarget = (liftTarget < 0) ? 0 : liftTarget;

	//Sets up static integers to keep track of the integral and previous error
	static int lIntegralLiftA = 0;
	static int rIntegralLiftA = 0;
	static int lPrevErrorLiftA = 0;
	static int rPrevErrorLiftA = 0;

	//Finds the error between the target and the actual value
	int lError = thousandthsToPot(LIFT, liftTarget, left) - SensorValue[lLiftPot];
	int rError = thousandthsToPot(LIFT, liftTarget, right) - SensorValue[rLiftPot];
	//Keeps track of the difference between the error and the previous error
	int lDerivative = lError - lPrevErrorLiftA;
	int rDerivative = rError - rPrevErrorLiftA;
	//Resets the previous error
	lPrevErrorLiftA = (!(time1(T2) % 1)) ? lError : lPrevErrorLiftA;
	rPrevErrorLiftA = (!(time1(T2) % 1)) ? rError : rPrevErrorLiftA;
	//Continuously adds the error to the integral count
	lIntegralLiftA += lError;
	rIntegralLiftA += rError;
	//Resets the integral if the drive isn't PID tuning
	lIntegralLiftA = (abs(lError) < LIFT_TOL) ? 0 : lIntegralLiftA;
	rIntegralLiftA = (abs(rError) < LIFT_TOL) ? 0 : rIntegralLiftA;

	//Sets the drive values equal to their respective variable multiplied by the tuning value
	int lDrive = (Kp_LIFT * lError) + (Ki_LIFT * lIntegralLiftA) + (Kd_LIFT * lDerivative);
	int rDrive = (Kp_LIFT * rError) + (Ki_LIFT * rIntegralLiftA) + (Kd_LIFT * rDerivative);

	liftMotorsSet(lDrive, rDrive);
}

/* SEE void pidTuneLift(int liftMGTarget)
*  The equivalent of the above function, but the target is passed by
*  reference rather than by value. This version of the function is
*  used during driver mode in conjunction with a local variable */
void pidTuneLift(int* liftTarget) {
	*liftTarget = (*liftTarget > 1000) ? 1000 : *liftTarget;
	*liftTarget = (*liftTarget < 0) ? 0 : *liftTarget;

	static int lIntegralLiftD = 0;
	static int rIntegralLiftD = 0;
	static int lPrevErrorLiftD = 0;
	static int rPrevErrorLiftD = 0;

	int lError = thousandthsToPot(LIFT, *liftTarget, left) - SensorValue[lLiftPot];
	int rError = thousandthsToPot(LIFT, *liftTarget, right) - SensorValue[rLiftPot];
	int lDerivative = lError - lPrevErrorLiftD;
	int rDerivative = rError - rPrevErrorLiftD;
	lPrevErrorLiftD = (!(time1(T2) % 1)) ? lError : lPrevErrorLiftD;
	rPrevErrorLiftD = (!(time1(T2) % 1)) ? rError : rPrevErrorLiftD;
	lIntegralLiftD += lError;
	rIntegralLiftD += rError;
	lIntegralLiftD = (abs(lError) < LIFT_TOL) ? 0 : lIntegralLiftD;
	rIntegralLiftD = (abs(rError) < LIFT_TOL) ? 0 : rIntegralLiftD;

	int lDrive = (Kp_LIFT * lError) + (Ki_LIFT * lIntegralLiftD) + (Kd_LIFT * lDerivative);
	int rDrive = (Kp_LIFT * rError) + (Ki_LIFT * rIntegralLiftD) + (Kd_LIFT * rDerivative);

	liftMotorsSet(lDrive, rDrive);
}

/* The robot drives a set distance in encoder ticks, given by
*  enTarget. It uses a formula to drive at a speed scaled to
*  the difference between the current displacement and the
*  final displacement.  It then drives backwards to counteract
*  any additional drift.  It also PID-tunes while doing so */
void waitDistance(const int* const targets, int enTarget, bool slowDown = false, float speedMultiplier = 1) {
	SensorValue[rightEn] = 0;		//Encoders zeroed
	SensorValue[leftEn] = 0;
	clearTimer(T1);							//Timer is cleared to make it give up if it takes too long

	int drive = 0;							//Variable for storing the speed the drive should travel at

	int a = 18;									//Variable that reduces drift when increased but also lowers speed

	if(!slowDown) {
		/* The robot uses a formula to scale speed to position if
		*  the velocity would be within the threshold to start
		*  driving, but otherwise sets the speed equal to the
		*  minimum threshold otherwise */
		while(abs(SensorValue[leftEn]) < abs(enTarget) && time1[T1] < GIVE_UP_TIME) {
			drive = sgn(enTarget) * (a * log(-abs(SensorValue[leftEn]) + abs(enTarget)) + (127 - (a * log(abs(enTarget)))));

			drive = (sgn(enTarget) > 0 && drive < LIN_THRESHOLD) ? LIN_THRESHOLD : drive;
			drive = (sgn(enTarget) < 0 && drive > -LIN_THRESHOLD) ? -LIN_THRESHOLD : drive;

			driveMotorsSet(drive, drive, -127, 127, speedMultiplier, speedMultiplier);
			pidTuneLiftMG(targets[LIFT_MG]);		//PID-tunes the claw and the lifts while driving
			pidTuneLift(targets[LIFT]);
			pidTuneClaw(targets[CLAW]);
		}

		//Motors drive backward briefly in order to counteract additional drift
		driveMotorsSet(-sgn(enTarget) * LIN_THRESHOLD, -sgn(enTarget) * LIN_THRESHOLD);
		wait1Msec(110);
		driveMotorsSet(0, 0);
	}
	/* This part is if the user doesn't want it to
	*  slow down as it reaches the target. This is
	*  helpful if the user want's to perform multiple
	*  tasks while driving a distance during auton */
	else if(slowDown) {
		while(abs(SensorValue[leftEn]) < abs(enTarget) && time1[T1] < GIVE_UP_TIME) {
			driveMotorsSet(sgn(enTarget) * 127, sgn(enTarget) * 127, -127, 127, speedMultiplier, speedMultiplier);
			pidTuneLiftMG(targets[LIFT_MG]);		//P-tunes the claw and the lifts while driving
			pidTuneLift(targets[LIFT]);
			pidTuneClaw(targets[CLAW]);
		}
	}
}

/* A function used in autonomous that tells the robot to rotate a
*  certain amount in tenths of a degree, using the VEX gyro */
void waitRotate(const int* const targets, int degrees10, bool slowDown = false, float speedMultiplier = 1) {
	//Multiplies the limit switch for the fieldside by the degrees, so that it is on the left side if the toggle variable is false
	degrees10 *= ((fieldSideToggle[0]) ? 1 : -1);
	SensorValue[yaw] = 0;				//Encoders zeroed
	clearTimer(T1);							//Timer is cleared to make it give up if it takes too long

	int drive = 0;							//Variable that contains the drive speed

	int a = 15;									//The intensity of the drive functoin

	/* Enacts the rotation to a set tenths of a degree (degrees10)
	*  while tuning both lifts. The rotation speed is tuned to
	*  decrease on a slope from 127 to the treshold. If it is past
	*  the threshold, it is set equal to the treshold, but with each
	*  side rotating in a different direction */
	if(!slowDown) {
		if(degrees10 > 0) {
			while(SensorValue[yaw] < degrees10 && time1(T1) < GIVE_UP_TIME) {
				drive = sgn(degrees10) * (a * log(-abs(SensorValue[yaw]) + abs(degrees10)) + (90 - (a * log(abs(degrees10)))));

				drive = (sgn(degrees10) > 0 && drive < LIN_THRESHOLD) ? LIN_THRESHOLD : drive;
				drive = (sgn(degrees10) < 0 && drive > -LIN_THRESHOLD) ? -LIN_THRESHOLD : drive;

				driveMotorsSet(-drive, drive, -90, 90, speedMultiplier, speedMultiplier);
				pidTuneLiftMG(targets[LIFT_MG]);		//PID-tunes the claws and the lift while rotating
				pidTuneLift(targets[LIFT]);
				pidTuneClaw(targets[CLAW]);
			}
		}
		else {
			while(SensorValue[yaw] > degrees10 && time1(T1) < GIVE_UP_TIME) {
				drive = sgn(degrees10) * (a * log(-abs(SensorValue[yaw]) + abs(degrees10)) + (90 - (a * log(abs(degrees10)))));

				drive = (sgn(degrees10) > 0 && drive < LIN_THRESHOLD) ? LIN_THRESHOLD : drive;
				drive = (sgn(degrees10) < 0 && drive > -LIN_THRESHOLD) ? -LIN_THRESHOLD : drive;

				driveMotorsSet(-drive, drive, -90, 90, speedMultiplier, speedMultiplier);
				pidTuneLiftMG(targets[LIFT_MG]);		//PID-tunes the claws and the lift while rotating
				pidTuneLift(targets[LIFT]);
				pidTuneClaw(targets[CLAW]);
			}
		}
		//Counteracts drift and turns off the drive motors when the rotation is complete
		driveMotorsSet(sgn(degrees10) * LIN_THRESHOLD, -sgn(degrees10) * LIN_THRESHOLD);
		wait1Msec(110);
		driveMotorsSet(0, 0);
	}
	/* This part is if the user doesn't want it to
	*  slow down as it reaches the target. This is
	*  helpful if the user want's to perform multiple
	*  tasks while driving a distance during auton */
	else if(slowDown) {
		if(degrees10 > 0) {
			while(SensorValue[yaw] < degrees10 && time1(T1) < GIVE_UP_TIME) {
				driveMotorsSet(90, -90, -90, 90, speedMultiplier, speedMultiplier);
				pidTuneLiftMG(targets[LIFT_MG]);		//PID-tunes the claws and the lift while rotating
				pidTuneLift(targets[LIFT]);
				pidTuneClaw(targets[CLAW]);
			}
		}
		else {
			while(SensorValue[yaw] > degrees10 && time1(T1) < GIVE_UP_TIME) {
				driveMotorsSet(-90, 90, -90, 90, speedMultiplier, speedMultiplier);
				pidTuneLiftMG(targets[LIFT_MG]);		//PID-tunes the claws and the lift while rotating
				pidTuneLift(targets[LIFT]);
				pidTuneClaw(targets[CLAW]);
			}
		}
	}
}

/* A function used in autonomous that tells the robot to move in a
*  curved path to a new coordinate that's outTargetX feet away
*  horizontally and outTargetY feet away vertically and the plane
*  is oriented depending on the rotation of the robot. It also has
*  the option to move backwards in a curved motion. The first part
*  of this function calculates the values that it will use and the
*  second part implements them */
void waitDistanceCurve(const int* const targets, int outTargetX, int outTargetY, bool backwards = false, bool slowDown = false, float speedMultiplier = 1) {
	//Sets up a variable in so that it can easily flip the direction if commanded to go backwards
	int direction = (backwards) ? -1 : 1;

	//Sets a new location depending on if the robot is supposed to go left or right
	int location = sgn(outTargetX) * WHEEL_TO_CENTER;

	//Sets up targets for the wheels on the inner side of the curve and gives them default values
	int inTargetX = 0;
	int inTargetY = outTargetY;

	/* Sets up a variable for the portion of the circle being
	*  calculated between the two points. To calculate it, the
	*  distance formula, arcsine, and the fact that all angles in
	*  a triangle add up to 180 are used. This also makes sure
	*  that the target coordinates aren't equal to values that
	*  would result in the function dividing by zero. If it's
	*  ordered to go backwards, the input value of outTargetY is
	*  flipped so that it still calculates it as if it were going
	*  forward */
	float theta = (outTargetX == - 2 * location && !outTargetY) ? 0 :
	180 - 2 * radiansToDegrees(asin((direction * outTargetY) / sqrt((pow(outTargetX + 2 * location, 2)) + (pow(outTargetY, 2)))));

	/* Calculates and sets the inner wheel targets using
	*  trigonometry. The value also depends on the direction
	*  that the robot is traveling */
	if(outTargetX > 0) {
		inTargetX = outTargetX + 2 * location * cosDegrees(theta);
		inTargetY = outTargetY - 2 * location * sinDegrees(theta);
	}
	else if(outTargetX < 0) {
		inTargetX = outTargetX + 2 * location * cosDegrees(theta);
		inTargetY = outTargetY + 2 * location * sinDegrees(theta);
	}

	/* Calculates the radios of the circle each path finds
	*  using the law of sines and makes sure that that it
	*  doesn't divide by zero */
	int outRadius = (theta) ? abs(outTargetX / (sin(theta))) : 0;
	int inRadius = (theta) ? abs(inTargetX / (sin(theta))) : 0;

	/* Calculates the distance it has to travels using the
	*  equation for the circumference of the circle dividing
	*  it by the potion of the circle being traveled in order
	*  to give each encoder a target value. It also converts
	*  the answer into encoder ticks so that it won't round the
	*  variable very much considering that it's an integer */
	int outDistance = 2 * PI * outRadius * (theta / 360);
	int inDistance = 2 * PI * inRadius * (theta / 360);

	/* Calculates the ratio between the target distances for the
	*  encoders so that it can multiply the inner motors by this
	*  speed. This will make sure that each side takes the same
	*  amount of time to cover their target distances. It also
	*  makes sure that it doesn't divide by zero */
	int speedRatio = (outDistance) ? inDistance / outDistance : 0;

	SensorValue[rightEn] = 0;	//Encoders zeroed
	SensorValue[leftEn] = 0;
	clearTimer(T1);						//Timer is cleared to make it give up if it takes too long

	int lDrive = 0;						//Variables for storing the speed the drives should travel at
	int rDrive = 0;

	int a = 18;								//Variable that reduces drift when increased but also lowers speed

	/* If the target involves turning right, the left encoder's
	*  target is the outer distnace and the inner encoder's target
	*  is the inner distance. The values are multiplied by the
	*  direction so that they flip if the robot is ordered to move
	*  backwards. It uses the same logarithmic tuner as the
	*  previous two functions and sets the motors equal to the
	*  threshold if the fall below the threshold. It then multiplies
	*  the right motor speed by the speed ratio since that's on the
	*  inner side so it'll have to move slower. It also p-tunes both
	*  lifts while moving. */
	if(!slowDown) {
		if(outTargetX > 0) {
			while((SensorValue[leftEn] < outDistance || SensorValue[rightEn] < inDistance) && time1[T1] < GIVE_UP_TIME) {
				lDrive = direction * a * log(-abs(SensorValue[leftEn]) + outDistance) + (127 - (a * log(outDistance)));
				rDrive = direction * a * log(-abs(SensorValue[rightEn]) + inDistance) + (127 - (a * log(inDistance)));

				lDrive = (lDrive < LIN_THRESHOLD) ? direction * LIN_THRESHOLD : lDrive;
				rDrive = (rDrive < LIN_THRESHOLD) ? direction * LIN_THRESHOLD : rDrive;

				driveMotorsSet(lDrive, rDrive, -127, 127, speedMultiplier, speedMultiplier * speedRatio);
				pidTuneLiftMG(targets[LIFT_MG]);
				pidTuneLift(targets[LIFT]);
				pidTuneClaw(targets[CLAW]);
			}
		}
		/* If the target involves turning left, the encoder sides are
		*  set to the opposite configuration. This has the same commands
		*  but it accounds for the inner distance being on the left. */
		else if(outTargetX < 0) {
			while((SensorValue[leftEn] < inDistance || SensorValue[rightEn] < outDistance) && time1[T1] < 5000) {
				lDrive = direction * a * log(-abs(SensorValue[leftEn]) + inDistance) + (127 - (a * log(inDistance)));
				rDrive = direction * a * log(-abs(SensorValue[rightEn]) + outDistance) + (127 - (a * log(outDistance)));

				lDrive = (lDrive < LIN_THRESHOLD) ? direction * LIN_THRESHOLD : lDrive;
				rDrive = (rDrive < LIN_THRESHOLD) ? direction * LIN_THRESHOLD : rDrive;

				driveMotorsSet(lDrive, rDrive, -127, 127, speedMultiplier * speedRatio, speedMultiplier);
				pidTuneLiftMG(targets[LIFT_MG]);
				pidTuneLift(targets[LIFT]);
				pidTuneClaw(targets[CLAW]);
			}
		}

		//Motors drive backward briefly in order to counteract additional drift
		driveMotorsSet(-direction * LIN_THRESHOLD, -direction * LIN_THRESHOLD);
		wait1Msec(110);
		driveMotorsSet(0, 0);
	}
	/* This part is if the user doesn't want it to
	*  slow down as it reaches the target. This is
	*  helpful if the user want's to perform multiple
	*  tasks while driving a distance during auton */
	else if(slowDown) {
		if(outTargetX > 0) {
			while((SensorValue[leftEn] < outDistance || SensorValue[rightEn] < inDistance) && time1[T1] < GIVE_UP_TIME) {
				driveMotorsSet(lDrive, rDrive, -127, 127, speedMultiplier, speedMultiplier * speedRatio);
				pidTuneLiftMG(targets[LIFT_MG]);		//PID-tunes the claws and the lift while rotating
				pidTuneLift(targets[LIFT]);
				pidTuneClaw(targets[CLAW]);
			}
		}
		else if(outTargetX < 0){
			while((SensorValue[leftEn] < inDistance || SensorValue[rightEn] < outDistance) && time1[T1] < 5000) {
				driveMotorsSet(lDrive, rDrive, -127, 127, speedMultiplier * speedRatio, speedMultiplier);
				pidTuneLiftMG(targets[LIFT_MG]);		//PID-tunes the claws and the lift while rotating
				pidTuneLift(targets[LIFT]);
				pidTuneClaw(targets[CLAW]);
			}
		}
	}
}

/* A somewhat general function used in autonomous that changes the
*  contents of the current target values for the lifts and claw,
*  and then pTunes both the lifts and claw with their new target
*  values */
void waitActions(int* targets, int liftMGTarget, int clawTarget, int liftTarget) {
	//Assigns the contents of targets to the new lift and claw target values
	targets[CLAW] = clawTarget;
	targets[LIFT_MG] = liftMGTarget;
	targets[LIFT] = liftTarget;
	//PID-tunes the lifts and the claw
	pidTuneClaw(targets[CLAW]);
	pidTuneLiftMG(targets[LIFT_MG]);
	pidTuneLift(targets[LIFT]);
}

/* Sets targets equal to the new values, then continues to test to see
*  if the claw is within the range specified by tolerance, which is
*  defined by the user or set equal to the default tolerance */
void testClaw(int* targets, int liftMGTarget, int clawTarget, int liftTarget, int accuracy = CLAW_ACC_TOL) {
	do {
		waitActions(targets, liftMGTarget, clawTarget, liftTarget);
	} while(potToThousandths(CLAW) < clawTarget - accuracy || potToThousandths(CLAW) > clawTarget + accuracy);
}

/* Specific function for PID-tuning just the claw */
void setClaw(int* targets, int clawTarget, int accuracy = CLAW_ACC_TOL) {
	testClaw(targets, targets[LIFT_MG], clawTarget, targets[LIFT], accuracy);
}

/* Sets targets equal to the new values, then continues to test to see
*  if the mobile goal lift is within the range specified by tolerance,
*  which is defined by the user or set equal to the default
*  tolerance */
void testLiftMG(int* targets, int liftMGTarget, int clawTarget, int liftTarget, int accuracy = LIFT_MG_ACC_TOL) {
	do {
		waitActions(targets, liftMGTarget, clawTarget, liftTarget);
	} while(potToThousandths(LIFT_MG) < liftMGTarget - accuracy || potToThousandths(LIFT_MG) > liftMGTarget + accuracy);
}

/* Specific function for PID-tuning just the mobile goal lift */
void setLiftMG(int* targets, int liftMGTarget, int accuracy = LIFT_MG_ACC_TOL) {
	testLiftMG(targets, liftMGTarget, targets[CLAW], targets[LIFT], accuracy);
}

/* Sets targets equal to the new values, then continues to test to see
*  if the lift is within the range specified by tolerance, which is
*  defined by the user or set equal to the default tolerance */
void testLift(int* targets, int liftMGTarget, int clawTarget, int liftTarget, int accuracy = LIFT_ACC_TOL) {
	do {
		waitActions(targets, liftMGTarget, clawTarget, liftTarget);
	} while(potToThousandths(LIFT) < liftTarget - accuracy || potToThousandths(LIFT) > liftTarget + accuracy);
}

/* Specific function for PID-tuning just the lift */
void setLift(int* targets, int liftTarget, int accuracy = LIFT_ACC_TOL) {
	testLift(targets, targets[LIFT_MG], targets[CLAW], liftTarget, accuracy);
}

void LCDAutonSelection()
{
	//Clears LCD and turn on backlight
	clearLCDLine(0);
	clearLCDLine(1);
	bLCDBacklight = true;

	//Displays default choices
	displayLCDString(0, 0, "Auton Settings:");
	displayLCDString(1, 0, "L     10pt    ON");

	while(bIfiRobotDisabled) {
		//Checks for the left button being pressed if the button isn't already pressed
		if(nLCDButtons & leftBtnVEX) toggleVariable(fieldSideToggle, true);
		else toggleVariable(fieldSideToggle, false);

		//Same toggle switch with the skills button
		if(nLCDButtons & centerBtnVEX) toggleVariable(autonTypeToggle, true, 3);
		else toggleVariable(autonTypeToggle, false, 3);

		//Same toggle switch for whether or not the auton will activate
		if(nLCDButtons & rightBtnVEX) toggleVariable(autonToggle, true);
		else toggleVariable(autonToggle, false);

		//Print various messages depending on the button state
		if(fieldSideToggle[0])
			displayLCDString(1, 0, "R");
		else if(!(fieldSideToggle[0]))
			displayLCDString(1, 0, "L");
		if(!(autonTypeToggle[0]))
			displayLCDString(1, 6, "10pt");
		else if(autonTypeToggle[0] == 1)
			displayLCDString(1, 6, "20pt");
		else if(autonTypeToggle[0] == 2)
			displayLCDString(1, 6, "Sk  ");
		if(autonToggle[0])
			displayLCDString(1, 13, "ON ");
		else if(!(autonToggle[0]))
			displayLCDString(1, 13, "OFF");
	}
}

//Function for calibrating the gyro
void calibrateGyro()
{
	SensorType[yaw] = sensorNone;	//Resets the gyroscope
	wait1Msec(1100);							//Provides time for calibration
	SensorType[yaw] = sensorGyro;	//Reassigns the yaw gyroscope's sensor type
	wait1Msec(1100);							//Waits for the gyro to calibrate

	SensorValue[rightEn] = 0;			//Zeroes the right encoder
	SensorValue[leftEn] = 0;			//Zeroes the left encoder
	playTone(1200, 50);						//Plays a tone when calibration is finished to alert the operator
}



/******************************************************************
/*
/*											 AUTONOMOUS CODE
/*
*******************************************************************/



void pre_auton()
{
	bStopTasksBetweenModes = true;

	//Calibrates the gyro and turns on the LCD
	calibrateGyro();
	LCDAutonSelection();
}

task autonomous()
{
	/* targets is an array of integers that stores the target
	*  values for the mglift, claw, rotation, and lift */
	int targets[N_TARGETS] = {potToThousandths(CLAW), potToThousandths(LIFT_MG), potToThousandths(LIFT)};

	//Only starts the autonomous if the togglestate is true
	if(autonToggle[0]) {
		// Skills Autonomous
		if(autonTypeToggle[0] == 2) {
		}

		//Regular Autonomous
		else {
			//Scores a mobile goal in the 20 point zone
			if(autonTypeToggle[0] == 1) {
				//GO FOR MOBILE GOAL
				setClaw(targets, 50);
				targets[LIFT] = 200;
				targets[LIFT_MG] = 1000;
				waitDistance(targets, 1400, false, 0.50);
				liftMGMotorsSet(-127);
				wait1Msec(200);
				liftMGMotorsSet(0);
				waitDistance(targets, 100);
				liftMGMotorsSet(-127);
				wait1Msec(1300);
				liftMGMotorsSet(0);
				targets[LIFT_MG] = 0;

				//SCORE PRE-LOAD
				targets[LIFT] = 50;
				waitDistance(targets, -300, true);
				targets[CLAW] = 1000;
				waitDistance(targets, -300, true);
				targets[CLAW] = 0;
				targets[LIFT] = 200;
				waitDistance(targets, -800);

				//SCORE MOBILE GOAL IN 20 POINT ZONE
				waitRotate(targets, -450);
				waitDistance(targets, -700);
				waitRotate(targets, -900);
				driveMotorsSet(127, 127);
				wait1Msec(1500);
				driveMotorsSet(0, 0);
				setClaw(targets, 0);
				liftMGMotorsSet(127);
				wait1Msec(1000);
				liftMGMotorsSet(0);
				setClaw(targets, 0);
				driveMotorsSet(-127, -127);
				wait1Msec(500);
				driveMotorsSet(0, 0);
				liftMGMotorsSet(-127);
				wait1Msec(200);
				liftMGMotorsSet(0);
				driveMotorsSet(-127, -127);
				wait1Msec(1000);
				driveMotorsSet(0, 0);
				setLift(targets, 200);
			}
			//Scores a mobile goal in the 10 point zone
			else if(!(autonTypeToggle[0])) {
				//GO FOR MOBILE GOAL
				setClaw(targets, 50);
				targets[LIFT] = 200;
				targets[LIFT_MG] = 1000;
				waitDistance(targets, 1400, false, 0.50);
				liftMGMotorsSet(-127);
				wait1Msec(200);
				liftMGMotorsSet(0);
				waitDistance(targets, 100);
				liftMGMotorsSet(-127);
				wait1Msec(1300);
				liftMGMotorsSet(0);
				targets[LIFT_MG] = 0;

				//SCORE PRE-LOAD
				targets[LIFT] = 0;
				waitDistance(targets, -300, true);
				targets[CLAW] = 1000;
				waitDistance(targets, -300, true);
				targets[CLAW] = 0;
				targets[LIFT] = 200;
				waitDistance(targets, -700);

				/*			//GO FOR SECOND CONE
				waitDistance(targets, 200);
				waitRotate(targets, -50);
				setLift(targets, 100);
				wait1Msec(300);
				setLift(targets, 300);
				setClaw(targets, 100);
				setLift(targets, 50);
				setClaw(targets, 1000);
				setLift(targets, 400);
				setClaw(targets, 100); */

				//SCORE MOBILE GOAL IN 10 POINT ZONE
				waitRotate(targets, -450);
				waitDistance(targets, -200);
				waitRotate(targets, -1150);
				targets[LIFT_MG] = 1000;
				waitDistance(targets, 250);
				setLiftMG(targets, 1000);
				liftMGMotorsSet(-127);
				wait1Msec(200);
				liftMGMotorsSet(0);
				waitDistance(targets, -200);
			}
		}
	}
}



/******************************************************************
/*
/*											 USER CONTROL
/*
*******************************************************************/



task usercontrol()
{
	clearTimer(T2);								//Clears the timer for the PID
	clearTimer(T3);								//Clears the timer for releasing a cone

	//Sets the targets equal to the current positions
	int liftTarget = potToThousandths(LIFT);
	int mgLiftTarget = potToThousandths(LIFT_MG);
	int clawTarget = potToThousandths(CLAW);

	int clawPosition = 0;
	int stackPhase = 0;
	int inHeight = 1000;

	int dif = 0;
	int dif1 = 0;
	int dif2 = 0;

	bool releaseCone = false;
	bool stackCancel = false;			//Variable for cancelling the autostack
	bool autoStack = true;				//Variable for turning the autostack on and off

	intakeMotorSet(40);

	while (1)
	{
		//Ch2					=		Right drive
		//Ch3					=		Left drive
		//5U and 5D		=		Lift
		//6U and 6D		=		Claw
		//7L					=		Mobile goal up
		//7D					=		Mobile goal down
		//8L					=		Auto load height
		//8U					=		Enable/disable autostack
		//8D					=		Stack height

		/*********************************
		/*		RESET SWITCH:
		*********************************/
		if(vexRT[Btn5U] && vexRT[Btn5D] && vexRT[Btn7U]) {
			allMotorsOff();
			clawTarget = potToThousandths(CLAW);
			liftTarget = potToThousandths(LIFT);
			mgLiftTarget = potToThousandths(LIFT_MG);
		}



		/*********************************
		/*		DRIVE:
		*********************************/
		driveMotorsSet(vexRT[Ch3], vexRT[Ch2]);



		/*********************************
		/*		CLAW:
		*********************************/
		if(!(time1(T2) % 4))
			dif1 = potToThousandths(LIFT);
		else if((time1(T2) % 4) == 2)
			dif2 = potToThousandths(LIFT);
		dif = dif2 - dif1;

		if(vexRT[Btn6U]) {
			//Sets the target position inward and cancels the auto stack in progress
			clawPosition = 0;
			stackCancel = true;
			stackPhase = 0;
		}
		else if(vexRT[Btn6D]) {
			//Sets the target position outward and cancels the auto stack in progress
			clawPosition = 1;
			stackCancel = true;
			stackPhase = 0;
		}
		//Button 6U and 6D take priority over autostack
		else {
			//Resets the cancel if the potentiometer goes below a certain height
			stackCancel = (potToThousandths(LIFT) < STACK_HEIGHT + 50) ? false : stackCancel;
			//If the autostack isn't canceled and is enabled
			if((!stackCancel) && autoStack && SensorValue(mgIn) < MG_THRESHOLD) {
				//Rotates inward if the lift is above the stack count and registers there is a cone
				if((SensorValue(Sonar) > SONAR_CONE + SONAR_TOL) && potToThousandths(LIFT) > STACK_HEIGHT + 50 && !stackPhase) {
					clawPosition = 0;
					stackPhase = 1;
					inHeight = potToThousandths(LIFT);
				}
				if(stackPhase == 1 && abs(dif) < RELEASE_THRESHOLD) {
					releaseCone = true;
					stackPhase = 2;
				}
				if(stackPhase == 2 && potToThousandths(LIFT) > inHeight) {
					clawPosition = 1;
					stackPhase = 0;
				}
			}
		}

		//Sets the motors equal to -127 if the potentiometer is greater than the minium
		clawTarget = (!clawPosition) ? 50 : 1000;

		pidTuneClaw(&clawTarget);



		/*********************************
		/*		INTAKE:
		*********************************/
		if(vexRT[Btn8R] || releaseCone) {
			clearTimer(T3);
			intakeMotorSet(-40);
		}
		else if(time1(T3) > 1000) {
			releaseCone = false;
			intakeMotorSet(40);
		}



		/*********************************
		/*		LIFT:
		*********************************/
		if(vexRT[Btn5U]) {
			//Sets the motors equal to 127 if the lift is less than the maximum and updates the lift target as it goes
			if(potToThousandths(LIFT) <= 1000) liftMotorsSet(127, 127);
			else liftMotorsSet(0, 0);

			liftTarget = potToThousandths(LIFT) + UP_ADD_HEIGHT;
		}
		else if(vexRT[Btn5D]) {
			//Sets the motors equal to -127 if the lift is greater than the minimum and updates the lift target as it goes
			if(potToThousandths(LIFT) >= 0) liftMotorsSet(-127, -127);
			else liftMotorsSet(0, 0);

			liftTarget = potToThousandths(LIFT) - DOWN_ADD_HEIGHT;
		}
		else {
			//Bounds the lift target between 0 and 1000
			rectify(liftTarget, 0, 1000);
			pidTuneLift(&liftTarget);
		}

		//Button for disabling the autostack
		if(vexRT[Btn8U]) toggleVariable(autoStackToggle, true, 2, true);
		else toggleVariable(autoStackToggle, false);

		//Buttons for setting the lift to preset heights
		if(vexRT[Btn8D]) liftTarget = STACK_HEIGHT;
		else if(vexRT[Btn8L]) liftTarget = LOAD_HEIGHT;



		/*********************************
		/*		MOBILE GOAL LIFT:
		*********************************/
		if(vexRT[Btn7L]) {
			//Sets the mobile goal motors equal to 127 if the mobile goal lift is less than the max
			if(potToThousandths(LIFT_MG) <= 1000 - LIFT_MG_TOL) liftMGMotorsSet(127);
			else liftMGMotorsSet(0);

			mgLiftTarget = potToThousandths(LIFT_MG) + 100;
		}
		else if(vexRT[Btn7D]) {
			//Sets the mobile goal motors equal to -127 if the mobile goal lift is greater than the min
			if(potToThousandths(LIFT_MG) >= LIFT_MG_TOL) liftMGMotorsSet(-127);
			else liftMGMotorsSet(0);

			mgLiftTarget = potToThousandths(LIFT_MG) - 100;
		}
		else {
			//Disables the motors if nothing is pressed
			rectify(mgLiftTarget, 0, 1000);
			pidTuneLiftMG(&mgLiftTarget);
		}

		wait1Msec(20);
	}
}
