#pragma config(Sensor, in1,    lLiftPot,       sensorPotentiometer)
#pragma config(Sensor, in2,    rLiftPot,       sensorPotentiometer)
#pragma config(Sensor, in3,    lLiftMGPot,     sensorPotentiometer)
#pragma config(Sensor, in4,    rLiftMGPot,     sensorPotentiometer)
#pragma config(Sensor, in5,    clawPot,        sensorPotentiometer)
#pragma config(Sensor, in6,    clawRotPot,     sensorNone)
#pragma config(Sensor, in7,    yaw,            sensorNone)
#pragma config(Sensor, dgtl1,  leftEn,         sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  rightEn,        sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  LCD,            sensorLEDtoVCC)
#pragma config(Motor,  port1,           bL,            tmotorVex393HighSpeed_HBridge, openLoop)
#pragma config(Motor,  port2,           fL,            tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port3,           bR,            tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port4,           fR,            tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port5,           lLift,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           rLift,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           lLiftMG,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           rLiftMG,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           claw,          tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          clawRot,       tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX2)

#pragma competitionControl(Competition)

#include "Vex_Competition_Includes.c"

#include "resources\tunes.h"

//Back left drive is in port 1
//Front left drive is in port 2
//Back right drive is in port 3
//Front right drive is in port 4
//Left lift is in port 5
//Right lift is in port 6
//Mobile goal claw left is in port 7
//Mobile goal claw right is in port 8
//Cone Claw is in port 9
//Cone Claw Rotate is in port 10



/******************************************************************
/*
/*											 USER CONSTANTS
/*
*******************************************************************/



const unsigned int STACK_HEIGHT = 100;
const unsigned int CONE_CLAW_GRAB = 400;

const unsigned int THRESHOLD = 35;					//Threshold for motors to work
const unsigned int LIFT_MG_TOL = 2;					//Mobile goal claw tolerance for p-tuning
const unsigned int CLAW_TOL = 2;						//Cone claw tolerance for p-tuning
const unsigned int CLAW_ROT_TOL = 2;				//Cone claw rotation tolerance for p-tuning
const unsigned int LIFT_TOL = 30;						//Lift tolerance for p-tuning

const unsigned int LIFT_MG_ACC_TOL = 80;		//The thousandths accuracy of the mobile goal claw
const unsigned int CLAW_ACC_TOL = 80;				//The thousandths accuracy of the cone claw
const unsigned int CLAW_ROT_ACC_TOL = 80;		//The thousandths accuracy of the cone claw rotation
const unsigned int LIFT_ACC_TOL = 100;			//The thousandths accuracy of the lift

const unsigned int L_LIFT_MG_MAX = 3030;
const unsigned int L_LIFT_MG_MIN = 410;
const unsigned int R_LIFT_MG_MAX = 3840;		//The maximum for the mobile goal lift potentiometer (lift at the top)
const unsigned int R_LIFT_MG_MIN = 1540;		//The minimum for the mobile goal lift potentiometer (lift at the bottom)

const unsigned int CLAW_MAX = 3860;					//The maximum for the cone claw potentiometer (claw completely open)
const unsigned int CLAW_MIN = 300;					//The minimum for the cone claw potentiometer (claw completely closed

const unsigned int CLAW_ROT_MAX = 3860;			//The maximum for the cone claw rotation (facing the mobile goal)
const unsigned int CLAW_ROT_MIN = 300;			//The minimum for the cone claw rotation (facing the front)

const unsigned int L_LIFT_MAX = 2660;				//The maximum for the lift potentiometer
const unsigned int L_LIFT_MIN = 830;				//The minimum for the lift potentiometer
const unsigned int R_LIFT_MAX = 2660;				//The maximum for the lift potentiometer
const unsigned int R_LIFT_MIN = 830;				//The minimum for the lift potentiometer

const float P_LIFT_MG = 0.1;								//The p-value for the mobile goal claw's movement
const float P_CLAW = 0.1;										//The p-value for the cone claw's movement
const float P_CLAW_ROT = 0.1;								//The p-value for the cone claw's rotation
const float P_LIFT = 0.15;									//The p-value for the lift's movement


//Enumerated type used for targets array in autonomous
enum targetTypes {
	CLAW				= 0,
	LIFT_MG			= 1,
	CLAW_ROT		= 2,
	LIFT				= 3,
	N_TARGETS		= 4
};

//Global Variables
unsigned int stackCountG = 0;
bool skillsToggleStateG = false;				//Variable to check if skills is toggled
bool skillsPressedG = false;						//Variable to check if the skills button is pressed
bool fieldSideToggleStateG = false;			//Variable to check which field side the robot is on
bool fieldSidePressedG = false;					//Variable to check if the field side button is pressed



/******************************************************************
/*
/*											 FUNCTIONS
/*
*******************************************************************/



/* A generic conversion function for converting from a thousandths to a potentiometer
value, for either the lift or claw's right or left side*/
float thousandthsToPot(targetTypes type, int thousandths, tDirections side = left) {
	//Stores desired extrema as floats to avoid later unit conversions.
	float max = (type == CLAW) ? CLAW_MAX :
	((type == CLAW_ROT) ? CLAW_ROT_MAX :
	((side == left) ?
	((type == LIFT_MG) ? L_LIFT_MG_MAX : L_LIFT_MAX) :
	((type == LIFT_MG) ? R_LIFT_MG_MAX : R_LIFT_MAX)));
	float min = (type == CLAW) ? CLAW_MIN :
	((type == CLAW_ROT) ? CLAW_ROT_MIN :
	((side == left) ?
	((type == LIFT_MG) ? L_LIFT_MG_MIN : L_LIFT_MIN) :
	((type == LIFT_MG) ? R_LIFT_MG_MIN : R_LIFT_MIN)));
	//Performs the calcualations and returns the desired value
	return (min + (max - min) * ((float)thousandths / 1000));
}

/* A generic conversion function for converting from a side of a system
that uses a potentiometer as  */
float potToThousandths(targetTypes type, tDirections side = left) {
	float max = (type == CLAW) ? CLAW_MAX :
	((type == CLAW_ROT) ? CLAW_ROT_MAX :
	((side == left) ?
	((type == LIFT_MG) ? L_LIFT_MG_MAX : L_LIFT_MAX) :
	((type == LIFT_MG) ? R_LIFT_MG_MAX : R_LIFT_MAX)));
	float min = (type == CLAW) ? CLAW_MIN :
	((type == CLAW_ROT) ? CLAW_ROT_MIN :
	((side == left) ?
	((type == LIFT_MG) ? L_LIFT_MG_MIN : L_LIFT_MIN) :
	((type == LIFT_MG) ? R_LIFT_MG_MIN : R_LIFT_MIN)));
	float potVal = (type == CLAW) ? SensorValue[clawPot] :
	((type == CLAW_ROT) ? SensorValue[clawRotPot] :
	((side == left) ?
	((type == LIFT_MG) ? SensorValue[lLiftMGPot] : SensorValue[lLiftPot]) :
	((type == LIFT_MG) ? SensorValue[rLiftMGPot] : SensorValue[rLiftPot])));
	//Performs the calculations and returns the desired value
	return 1000 * ((potVal - min) / (max - min));
}

/* P-tunes the mobile goal claw to a specified claw target, which is a thousandths value
* along the range of the claw.
* This version of the function is used during autonomous in conjunction with an array.*/
void pTuneMGLift(int liftMGTarget) {
	//The claw motor is set equal to it's error multiplied by the p-value
	if(liftMGTarget > 1000)			//The claw target is corrected if it is above the maximum
		liftMGTarget = 1000;
	else if(liftMGTarget < 0)		//The claw target is corrected if it is below the minimum
		liftMGTarget = 0;
	//Finds the error mutplied by the p-value of the claw
	int lLiftMGError = P_LIFT_MG * (thousandthsToPot(LIFT_MG, liftMGTarget, left) - SensorValue[lLiftMGPot]);
	int rLiftMGError = P_LIFT_MG * (thousandthsToPot(LIFT_MG, liftMGTarget, right) - SensorValue[rLiftMGPot]);
	//The claw only p-tunes if the error is above the tolerance
	motor[lLiftMG] = (abs(lLiftMGError) >= LIFT_MG_TOL) ? lLiftMGError : 0;
	motor[rLiftMG] = (abs(rLiftMGError) >= LIFT_MG_TOL) ? rLiftMGError : 0;
}

/* SEE void pTuneClaw(int clawTarget)
* The equivalent of the above function, but the target is passed by reference rather
* than by value.
* This version of the function is used during driver mode in conjunction with a local variable.*/
void pTuneMGLift(int* liftMGTarget) {
	if(*liftMGTarget > 1000)
		*liftMGTarget = 1000;
	else if(*liftMGTarget < 0)
		*liftMGTarget = 0;
	int lLiftMGError = P_LIFT_MG * (thousandthsToPot(LIFT_MG, *liftMGTarget, left) - SensorValue[lLiftMGPot]);
	int rLiftMGError = P_LIFT_MG * (thousandthsToPot(LIFT_MG, *liftMGTarget, right) - SensorValue[rLiftMGPot]);
	motor[rLiftMG] = (abs(lLiftMGError) >= LIFT_MG_TOL) ? lLiftMGError : 0;
	motor[lLiftMG] = (abs(rLiftMGError) >= LIFT_MG_TOL) ? rLiftMGError : 0;
}

/* P-tunes the cone claw to a specified claw target, which is a thousandths value
* along the range of the claw.
* This version of the function is used during autonomous in conjunction with an array.*/
void pTuneClaw(int clawTarget) {
	//The claw motor is set equal to it's error multiplied by the p-value
	if(clawTarget > 1000)			//The claw target is corrected if it is above the maximum
		clawTarget = 1000;
	else if(clawTarget < 0)		//The claw target is corrected if it is below the minimum
		clawTarget = 0;
	//Finds the error mutplied by the p-value of the claw
	int clawError = P_CLAW * (thousandthsToPot(CLAW, clawTarget) - SensorValue[clawPot]);
	//The claw only p-tunes if the error is above the tolerance
	motor[claw] = (abs(clawError) >= CLAW_TOL) ? clawError : 0;
}

/* SEE void pTuneClaw(int clawTarget)
* The equivalent of the above function, but the target is passed by reference rather
* than by value.
* This version of the function is used during driver mode in conjunction with a local variable.*/
void pTuneClaw(int* clawTarget) {
	if(*clawTarget > 1000)
		*clawTarget = 1000;
	else if(*clawTarget < 0)
		*clawTarget = 0;
	int clawError = P_CLAW * (thousandthsToPot(CLAW, *clawTarget) - SensorValue[clawPot]);
	motor[claw] = (abs(clawError) >= CLAW_TOL) ? clawError : 0;
}

/* P-tunes the cone claw rotation to a specified rotation claw target, which is a thousandths value
* along the range of the claw.
* This version of the function is used during autonomous in conjunction with an array.*/
void pTuneClawRot(int clawRotTarget) {
	//The claw rotation motor is set equal to it's error multiplied by the p-value
	if(clawRotTarget > 1000)		//The claw rotation target is corrected if it is above the maximum
		clawRotTarget = 1000;
	else if(clawRotTarget < 0)	//The claw rotation target is corrected if it is below the minimum
		clawRotTarget = 0;
	//Finds the error mutplied by the p-value of the claw
	int clawRotError = P_CLAW_ROT * (thousandthsToPot(CLAW_ROT, clawRotTarget) - SensorValue[clawRotPot]);
	//The claw only p-tunes if the error is above the tolerance
	motor[clawRot] = (abs(clawRotError) >= CLAW_ROT_TOL) ? clawRotError : 0;
}

/* SEE void pTuneClawRot(int clawRotTarget)
* The equivalent of the above function, but the target is passed by reference rather
* than by value.
* This version of the function is used during driver mode in conjunction with a local variable.*/
void pTuneClawRot(int* clawRotTarget) {
	if(*clawRotTarget > 1000)
		*clawRotTarget = 1000;
	else if(*clawRotTarget < 0)
		*clawRotTarget = 0;
	int clawRotError = P_CLAW_ROT * (thousandthsToPot(CLAW_ROT, *clawRotTarget) - SensorValue[clawRotPot]);
	motor[clawRot] = (abs(clawRotError) >= CLAW_ROT_TOL) ? clawRotError : 0;
}

/* P-tunes the lift to a specified lift target, which is a thousandths value
* along the range of the lift.  The lift is at its maximum when the thousandths
* value is 0, and at its minimum when it is 1000.
* This version of the function is used during autonomous in conjunction with an array.*/
void pTuneLift(int liftTarget) {
	if(liftTarget > 1000)			//The lift target is corrected if it is above the maximum
		liftTarget = 1000;
	else if(liftTarget < 0)		//The lift target is corrected if it is below the minimum
		liftTarget = 0;
	//Finds the error mutplied by the p-value of both sides of the lift
	int lError = P_LIFT * (thousandthsToPot(LIFT, liftTarget, left) - SensorValue[lLiftPot]);
	int rError = P_LIFT * (thousandthsToPot(LIFT, liftTarget, right) - SensorValue[rLiftPot]);
	//The lift only p-tunes if the error is above the tolerance
	motor[lLift] = (abs(lError) >= LIFT_TOL) ? lError : 0;
	motor[rLift] = (abs(rError) >= LIFT_TOL) ? rError : 0;
}

/* SEE void pTuneLift(int liftTarget)
* The equivalent of the above function, but the target is passed by reference rather
* than by value.
* This version of the function is used during driver mode in conjunction with a local variable.*/
void pTuneLift(int* liftTarget) {
	if(*liftTarget > 1000)
		*liftTarget = 1000;
	else if(*liftTarget < 0)
		*liftTarget = 0;
	int lError = P_LIFT * (thousandthsToPot(LIFT, *liftTarget, left) - SensorValue[lLiftPot]);
	int rError = P_LIFT * (thousandthsToPot(LIFT, *liftTarget, right) - SensorValue[rLiftPot]);
	motor[lLift] = (abs(lError) >= LIFT_TOL) ? lError : 0;
	motor[rLift] = (abs(rError) >= LIFT_TOL) ? rError : 0;
}

/* The robot drives a set distance in encoder ticks, given by enTarget.
* It uses a formula to drive at a speed scaled to the difference between
* the current displacement and the final displacement.  It then drives
* backwards to counteract any additional drift.  It p-tunes while doing so.*/
void waitDistance(const int* const targets, int enTarget) {
	SensorValue[rightEn] = 0;		//Encoders zeroed
	SensorValue[leftEn] = 0;
	clearTimer(T1);

	int drive = 0;							//Stores the speed the drive should travel at

	int a = 18;									//Variable that reduces drift when increased but also lowers speed

	/*The robot uses a formula to scale speed to position if the velocity would
	* be within the threshold to start driving, but otherwise sets the speed equal
	* to the minimum threshold otherwise.*/
	while(abs(SensorValue[leftEn]) < abs(enTarget) && time1[T1] < 5000) {
		drive = sgn(enTarget) * (a * log(-abs(SensorValue[leftEn]) + abs(enTarget)) + (127 - (a * log(abs(enTarget)))));
		if(sgn(enTarget) > 0 && drive < THRESHOLD) {
			drive = THRESHOLD;
		}
		else if(sgn(enTarget) < 0 && drive > -THRESHOLD) {
			drive = -THRESHOLD;
		}
		motor[bR] = motor[fR] = motor[bL] = motor[fL] = drive;
		pTuneMGLift(targets[LIFT_MG]);		//P-tunes the claws and the lift while driving
		pTuneClaw(targets[CLAW]);
		pTuneClawRot(targets[CLAW_ROT]);
		pTuneLift(targets[LIFT]);
	}

	//Motors drive backward briefly in order to counteract additional drift
	motor[bR] = motor[fR] = motor[bL] = motor[fL] = -sgn(enTarget) * THRESHOLD;
	wait1Msec(110);
	motor[bR] = motor[fR] = motor[bL] = motor[fL] = 0;
}

/* A function used in autonomous that tells the robot to rotate a certain amount
* in tenths of a degree, using the VEX gyro. */
void waitRotate(const int* const targets, int degrees10) {
	//Multiplies the limit switch for the fieldside by the degrees, so that it is on the left side if the switch is down
	SensorValue[yaw] = 0;
	clearTimer(T1);
	degrees10 *= ((fieldSideToggleStateG) ? 1 : -1);

	int drive = 0;							//Contains the drive speed

	int a = 15;									//The intensity of the drive functoin

	/* Enacts the rotation to a set tenths of a degree (degrees10) while tuning the lift
	* The rotation speed is tuned to decrease on a slope from 127 to the treshold.
	* If it is past the threshold, it is set equal to the treshold, but with each side
	* rotating in a different direction. */
	if(degrees10 > 0) {
		while(SensorValue[yaw] < degrees10 && time1(T1) < 5000) {
			drive = sgn(degrees10) * (a * log(-abs(SensorValue[yaw]) + abs(degrees10)) + (90 - (a * log(abs(degrees10)))));
			if(abs(drive) > 90) {
				drive = sgn(degrees10) * 90;
			}
			else if(sgn(degrees10) > 0 && drive < THRESHOLD) {
				drive = THRESHOLD;
			}
			else if(sgn(degrees10) < 0 && drive > -THRESHOLD) {
				drive = -THRESHOLD;
			}
			motor[bR] = motor[fR] = drive;		//The right side moves forwards
			motor[bL] = motor[fL] = -drive;		//The left side moves backwards
			pTuneMGLift(targets[LIFT_MG]);		//P-tunes the claws and the lift while rotating
			pTuneClaw(targets[CLAW]);
			pTuneClawRot(targets[CLAW_ROT]);
			pTuneLift(targets[LIFT]);
		}
	}
	else {
		while(SensorValue[yaw] > degrees10) {
			drive = sgn(degrees10) * (a * log(-abs(SensorValue[yaw]) + abs(degrees10)) + (90 - (a * log(abs(degrees10)))));
			if(abs(drive) > 90) {
				drive = sgn(degrees10) * 90;
			}
			else if(sgn(degrees10) > 0 && drive < THRESHOLD) {
				drive = THRESHOLD;
			}
			else if(sgn(degrees10) < 0 && drive > -THRESHOLD) {
				drive = -THRESHOLD;
			}
			motor[bR] = motor[fR] = drive;		//The right side moves forwards
			motor[bL] = motor[fL] = -drive;		//The left side moves backwards
			pTuneMGLift(targets[LIFT_MG]);		//P-tunes the claws and the lift while rotating
			pTuneClaw(targets[CLAW]);
			pTuneClawRot(targets[CLAW_ROT]);
			pTuneLift(targets[LIFT]);
		}
	}
	//Turns off the drive motors when the rotation is complete
	motor[bR] = motor[fR] = -sgn(degrees10) * THRESHOLD;
	motor[bL] = motor[fL] = sgn(degrees10) * THRESHOLD;
	wait1Msec(110);
	motor[bR] = motor[fR] = motor[bL] = motor[fL] = 0;
}

/* A somewhat general function used in autonomous that changes the contents
* of the current target values for the lift and the claw, and then pTunes both
* the lift and claw with their new target values. */
void waitActions(int* targets, int liftMGTarget, int clawTarget, int clawRotTarget, int liftTarget) {
	//Assigns the contents of targets to the new lift and claw target values
	targets[CLAW] = clawTarget;
	targets[LIFT_MG] = liftMGTarget;
	targets[CLAW_ROT] = clawRotTarget;
	targets[LIFT] = liftTarget;
	//P-tunes the lift and claw
	pTuneMGLift(targets[LIFT_MG]);
	pTuneClaw(targets[CLAW]);
	pTuneClawRot(targets[CLAW_ROT]);
	pTuneLift(targets[LIFT]);
}

/* Sets targets equal to the new values, then continues to test to see if the claw is within
the range specified by tolerance, which is defined by the user or set equal to the default tolerance */
void testMGLift(int* targets, int liftMGTarget, int clawTarget, int clawRotTarget, int liftTarget, int accuracy = LIFT_MG_ACC_TOL) {
	do {
		waitActions(targets, liftMGTarget, clawTarget, clawRotTarget, liftTarget);
	} while(potToThousandths(LIFT_MG) < liftMGTarget - accuracy || potToThousandths(LIFT_MG) > liftMGTarget + accuracy);
}

void setMGLift(int* targets, int liftMGTarget, int accuracy = LIFT_MG_ACC_TOL) {
	testMGLift(targets, liftMGTarget, targets[CLAW], targets[CLAW_ROT], targets[LIFT], accuracy);
}

/* Sets targets equal to the new values, then continues to test to see if the claw is within
the range specified by tolerance, which is defined by the user or set equal to the default tolerance */
void testClaw(int* targets, int liftMGTarget, int clawTarget, int clawRotTarget, int liftTarget, int accuracy = CLAW_ACC_TOL) {
	do {
		waitActions(targets, liftMGTarget, clawTarget, clawRotTarget, liftTarget);
	} while(potToThousandths(CLAW) < clawTarget - accuracy || potToThousandths(CLAW) > clawTarget + accuracy);
}

void setClaw(int* targets, int clawTarget, int accuracy = CLAW_ACC_TOL) {
	testClaw(targets, targets[LIFT_MG], clawTarget, targets[CLAW_ROT], targets[LIFT], accuracy);
}

/* Sets targets equal to the new values, then continues to test to see if the claw rotation is within
the range specified by tolerance, which is defined by the user or set equal to the default tolerance */
void testClawRot(int* targets, int liftMGTarget, int clawTarget, int clawRotTarget, int liftTarget, int accuracy = CLAW_ROT_ACC_TOL) {
	do {
		waitActions(targets, clawTarget, liftMGTarget, clawRotTarget, liftTarget);
	} while(potToThousandths(CLAW_ROT) < clawRotTarget - accuracy || potToThousandths(CLAW_ROT) > clawRotTarget + accuracy);
}

void setClawRot(int* targets, int clawRotTarget, int accuracy = CLAW_ROT_ACC_TOL) {
	testClawRot(targets, targets[LIFT_MG], targets[CLAW], clawRotTarget, targets[LIFT], accuracy);
}

/* Sets targets equal to the new values, then sets the claw and continues to tune
* the lift until it is within the range specified by the tolerance.
* The tolerance is set to be the default LIFT_ACC_TOL by default.*/
void testLift(int* targets, int liftMGTarget, int clawTarget, int clawRotTarget, int liftTarget, int accuracy = LIFT_ACC_TOL) {
	do {
		waitActions(targets, clawTarget, liftMGTarget, clawRotTarget, liftTarget);
	} while(potToThousandths(LIFT) < liftTarget - accuracy || potToThousandths(LIFT) > liftTarget + accuracy);
}

void setLift(int* targets, int liftTarget, int accuracy = LIFT_ACC_TOL) {
	testLift(targets, targets[LIFT_MG], targets[CLAW], targets[CLAW_ROT], liftTarget, accuracy);
}

void stackReset(int* targets) {
	int* stackCountL = &stackCountG;
	*stackCountL = 0;
}

void stackCone(int* targets) {
	int* stackCountL = &stackCountG;
	pTuneClaw(0);

}

/* Eliminates motor whine on the drive during user control */
int axesFix(int remote) {
	if(abs(remote) >= THRESHOLD) 		//Returns 0 if the value does not pass the TRESHOLD constant
		return remote;
	else
		return 0;
}



/******************************************************************
/*
/*											 TASKS
/*
*******************************************************************/



//Task for displaying the battery on the LCD Screen
task displayBattery()
{
	bool toggleSwitch = false;					//Toggle switch variable
	string mainBattery, backupBattery;	//Setup two strings
	while(1) {
		//Toggle switch code for turning on and off
		if(nLCDButtons) {
			toggleSwitch = !toggleSwitch;
			wait1Msec(500);
		}
		if(toggleSwitch) {
			bLCDBacklight = true;     		 	//Turn on LCD Backlight
			clearLCDLine(0);         		   	//Clear line 1 of the LCD
			clearLCDLine(1);          		 	//Clear line 2 of the LCD

			//Display the Primary Robot battery voltage
			displayLCDString(0, 0, "Primary: ");
			sprintf(mainBattery, "%1.2f%c", nImmediateBatteryLevel/1000.0,'V'); //Build the value to be displayed
			displayNextLCDString(mainBattery);

			//Display the Backup battery voltage
			displayLCDString(1, 0, "Backup: ");
			sprintf(backupBattery, "%1.2f%c", BackupBatteryLevel/1000.0, 'V');	//Build the value to be displayed
			displayNextLCDString(backupBattery);

			//Short delay for the LCD refresh rate
			wait1Msec(100);
		}
		else {
			bLCDBacklight = false;     		 	//Turn off LCD Backlight
			clearLCDLine(0);         		   	//Clear line 1 of the LCD
			clearLCDLine(1);          		 	//Clear line 2 of the LCD
		}
	}
}

task calibrateGyro()
{
	SensorType[yaw] = sensorNone;			//Resets the gyroscope
	wait1Msec(1100);									//Provides time for calibration
	SensorType[yaw] = sensorGyro;			//Reassigns the yaw gyroscope's sensor type
	wait1Msec(1100);									//Waits for the gyro to calibrate

	SensorValue[rightEn] = 0;					//Zeroes the right encoder
	SensorValue[leftEn] = 0;					//Zeroes the left encoder
	playTone(1200, 50);								//Plays a tone when calibration is finished to alert the operator
}



/******************************************************************
/*
/*											 AUTONOMOUS CODE
/*
*******************************************************************/



void pre_auton()
{
	bStopTasksBetweenModes = false;
	startTask(calibrateGyro);

	bool* fieldSideToggleStateL = &fieldSideToggleStateG;
	bool* fieldSidePressedL = &fieldSidePressedG;
	bool* skillsToggleStateL = &skillsToggleStateG;
	bool* skillsPressedL = &skillsPressedG;

	bLCDBacklight = true;			//Turn the backlight for the LCD On

	//Default messasges
	displayLCDString(0, 0, "Auton Settings:");
	displayLCDString(1, 0, "L      NoSk     ");

	while(1) {
		//Check for the left button being pressed if the button isn't already pressed
		if((nLCDButtons & leftBtnVEX) && !(*fieldSidePressedL)) {
			*fieldSideToggleStateL = !(*fieldSideToggleStateL);				//Change the toggle state
			*fieldSidePressedL = true;																//Note that the button is pressed
		}
		//If the left button isn't pressed
		else if (!(nLCDButtons & leftBtnVEX)) {
			*fieldSidePressedL = false;																//Note that the button is not pressed
		}

		//Same toggle switch with another button
		if((nLCDButtons & centerBtnVEX) && !(*skillsPressedL)) {
			*skillsToggleStateL = !(*skillsToggleStateL);
			*skillsPressedL = true;
		}
		else if (!(nLCDButtons & centerBtnVEX)) {
			*skillsPressedL = false;
		}

		//Print various messages depending on the button state
		if(*fieldSideToggleStateL)
			displayLCDString(1, 0, "R");
		else if(!(*fieldSideToggleStateL))
			displayLCDString(1, 0, "L");
		if(*skillsToggleStateL)
			displayLCDString(1, 7, "NoSk");
		else if(!(*skillsToggleStateL))
			displayLCDString(1, 7, "Sk  ");
	}
}

task autonomous()
{
	//targets is an array of integers that stores the target values for the lift, cone claw, mobile goal claw, and rotation of the cone claw
	int targets[N_TARGETS] = {1000, 1000, 0, 0};	//NOTE- CHANGE THESE DEFAULTS LATER!!!

	// Skills Autonomous
	if(skillsToggleStateG) {
	}

	//Regular Autonomous
	else {
	}
}



/******************************************************************
/*
/*											 USER CONTROL
/*
*******************************************************************/



task usercontrol()
{
	startTask(manageMusic);														//Plays randomly-chosen music in the last seconds of a match
	startTask(displayBattery);												//Display the battery voltage

	int liftTarget = potToThousandths(LIFT);					//The lift target starts wherever the lift is
	int clawRotTarget = potToThousandths(CLAW_ROT);

	clearTimer(T1);

	while (1)
	{
		//5U and 5D		=		Lift
		//6U and 6D		=		Cone claw rotation
		//7L					=		Mobile goal up
		//7D					=		Mobile goal down
		//7R					=		Stack cone
		//8L					=		Reset count
		//8R					=		Cone claw open
		//8D					=		Cone claw closed

		//The drive:
		motor[fR] = motor[bR] = axesFix(vexRT[Ch2]);
		motor[fL] = motor[bL] = axesFix(vexRT[Ch3]);

		//Lift input:
		if(vexRT[Btn5U] || vexRT[Btn5D])									//5U and 5D shoulder buttons increment and decrement the lift target
			liftTarget -= (vexRT[Btn5U] - vexRT[Btn5D]);

		pTuneLift(&liftTarget);														//P-tunes the lift

		//Rotate claw input:
		if(vexRT[Btn6U] || vexRT[Btn6D])									//The claw target is maintained or changed if certain conditions are met
			clawRotTarget -= (vexRT[Btn6U] - vexRT[Btn6D]);

		pTuneClawRot(&clawRotTarget);										//P-tunes the cone claw

		//Mobile goal lift input:
		if(vexRT[Btn7L])
			pTuneMGLift(1000);
		else if(vexRT[Btn7D])
			pTuneMGLift(0);

		//Cone claw input:
		if(vexRT[Btn8R])
			pTuneClaw(1000);
		else if(vexRT[Btn8D])
			pTuneClaw(0);
	}
}
