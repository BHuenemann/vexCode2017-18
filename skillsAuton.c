#pragma config(UART_Usage, UART1, uartVEXLCD, baudRate19200, IOPins, None, None)
#pragma config(UART_Usage, UART2, uartNotUsed, baudRate4800, IOPins, None, None)
#pragma config(Sensor, in1,    lLiftPot,       sensorNone)
#pragma config(Sensor, in2,    mgPot,          sensorPotentiometer)
#pragma config(Sensor, in3,    clawPot,        sensorPotentiometer)
#pragma config(Sensor, in4,    rLiftPot,       sensorPotentiometer)
#pragma config(Sensor, in5,    yaw,            sensorNone)
#pragma config(Sensor, dgtl1,  rightEn,        sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  leftEn,         sensorQuadEncoder)
#pragma config(Sensor, dgtl11, LCD,            sensorNone)
#pragma config(Motor,  port1,           rLift,         tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           lLiftMG,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           rLiftMG,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           lLift,         tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           fL,            tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           fR,            tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           bL,            tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           bR,            tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           lClaw,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          rClaw,         tmotorVex393_HBridge, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX2)

#pragma competitionControl(Competition)

#include "Vex_Competition_Includes.c"
#include "LCDDUMB.h"

//#include "resources\tunes.h"

//Right mobile goal lift is in port 1
//Left mobile goal lift is in port 2
//Right lift motor is in port 3
//Left lift motor is in port 4
//Right claw motor is in port 5
//Left claw motor is in port 6
//Front right drive is in port 7
//Back right drive is in port 8
//Front left drive is in port 9
//Back left drive is in port 10



/******************************************************************
/*
/*											 USER CONSTANTS
/*
*******************************************************************/



const unsigned int STACK_HEIGHT = 60;		//Height for lift to raise with each cone stack
const unsigned int BASE_HEIGHT = 155;		//Height for lift with a mobile goal

const unsigned int WHEEL_TO_CENTER = 7;	//Width from average x-location of wheels to the center of the robot

const unsigned int THRESHOLD = 35;			//Threshold for motors to work
const unsigned int CLAW_TOL = 100;				//Claw tolerance for p-tuning
const unsigned int LIFT_MG_TOL = 20;		//Mobile goal lift tolerance for p-tuning
const unsigned int LIFT_TOL = 20;				//Lift tolerance for p-tuning
const unsigned int GIVE_UP_TIME = 3000;	//Time to give functions before it gives up on it's target

const unsigned int CLAW_ACC_TOL = 50;		//The thousandths accuracy of the claw
const unsigned int LIFT_MG_ACC_TOL = 50;//The thousandths accuracy of the mobile goal lift
const unsigned int LIFT_ACC_TOL = 50;		//The thousandths accuracy of the lift

const unsigned int CLAW_MAX = 2295;			//The maximum for the claw potentiometer
const unsigned int CLAW_MIN = 815;			//The minimum for the claw potentiometer

const unsigned int LIFT_MG_MAX = 3200;	//The maximum for the left mobile goal lift potentiometer (lift deployed)
const unsigned int LIFT_MG_MIN = 730;		//The minimum for the left mobile goal lift potentiometer (lift undeployed)

const unsigned int L_LIFT_MAX = 3050;		//The maximum for the left lift potentiometer
const unsigned int L_LIFT_MIN = 1470;		//The minimum for the left lift potentiometer
const unsigned int R_LIFT_MAX = 3220;		//The maximum for the right lift potentiometer
const unsigned int R_LIFT_MIN = 1620;		//The minimum for the right lift potentiometer

const float P_LIFT_MG = 0.1;						//The p-value for the mobile goal lift's movement
const float P_LIFT = 0.6;								//The p-value for the lift's movement during autonomous
const float Kp_LIFT = 0.6;							//PID values for tuning the lift during user control
const float Ki_LIFT = 0.0008;
const float Kd_LIFT = 5;



//Enumerated type used for targets array in autonomous
enum targetTypes {
	CLAW				= 0,
	LIFT_MG			= 1,
	LIFT				= 2,
	N_TARGETS		= 3
};

//Static variable used for stack count
static int stackCount = 0;								//Variable to count the amount of cones stacked
//Static Variables for toggle switches
static bool skillsToggleState = true;		//Variable to check if skills is toggled
static bool skillsPressed = false;				//Variable to check if the skills button is pressed
static bool fieldSideToggleState = false;	//Variable to check which field side the robot is on
static bool fieldSidePressed = false;			//Variable to check if the field side button is pressed
static bool autonToggleState = true;			//Variable to check if auton should run
static bool autonPressed = false;					//Variable to check if the auton button is pressed



/******************************************************************
/*
/*											 FUNCTIONS
/*
*******************************************************************/



/* A generic conversion function for converting from a thousandths to a potentiometer value
*  for either the mobile goal lift or left/right lift */
float thousandthsToPot(targetTypes type, int thousandths, tDirections side = left) {
	//Stores desired extrema as floats to avoid later unit conversions
	float max = (type == LIFT_MG) ? LIFT_MG_MAX :
	((type == CLAW) ? CLAW_MAX :
	((side == left) ? L_LIFT_MAX : R_LIFT_MAX));
	float min = (type == LIFT_MG) ? LIFT_MG_MIN :
	((type == CLAW) ? CLAW_MIN :
	((side == left) ? L_LIFT_MIN : R_LIFT_MIN));
	//Performs the calcualations and returns the desired value
	return (min + (max - min) * ((float)thousandths / 1000));
}

/* A generic conversion function for converting from a side of a system that uses a
*  potentiometer to a thousandths of a potentiometer value */
float potToThousandths(targetTypes type, tDirections side = left) {
	//Stores desired extrema as floats to avoid later unit conversions
	float max = (type == LIFT_MG) ? LIFT_MG_MAX :
	((type == CLAW) ? CLAW_MAX :
	((side == left) ? L_LIFT_MAX : R_LIFT_MAX));
	float min = (type == LIFT_MG) ? LIFT_MG_MIN :
	((type == CLAW) ? CLAW_MIN :
	((side == left) ? L_LIFT_MIN : R_LIFT_MIN));
	//Stores the current potentiometer value
	float potVal = (type == LIFT_MG) ? SensorValue[mgPot] :
	((type == CLAW) ? SensorValue[clawPot] :
	((side == left) ? SensorValue[lLiftPot] : SensorValue[rLiftPot]));
	//Performs the calculations and returns the desired value
	return 1000 * ((potVal - min) / (max - min));
}

/* Basic conversion for converting inches driven to encoder ticks
*  that can be used for p-tuning */
float inchesToEncoderTicks(float inches) {
	float encoderTicks = 90 * PI * inches;
	return encoderTicks;
}

/* Sets the claw equal to a motor speed depending on the
*  position. It also makes sure that the potentiometer
*  isn't at it's max or min */
void setClaw(int clawTarget) {
	if(clawTarget < potToThousandths(CLAW) - CLAW_TOL)
		motor[lClaw] = motor[rClaw] = (potToThousandths(CLAW) >= CLAW_TOL) ? 127 : 0;
	else if(clawTarget > potToThousandths(CLAW) + CLAW_TOL)
		motor[lClaw] = motor[rClaw] = (potToThousandths(CLAW) <= 1000 - CLAW_TOL) ? -127 : 0;
	else
		motor[lClaw] = motor[rClaw] = 0;
}

/* P-tunes the mobile goal lift to a specified mobile goal lift
*  target, which is a thousandths value along the range of the
*  claw. This version of the function is used during autonomous
*  in conjunction with an array */
void pTuneMGLift(int liftMGTarget) {
	//The mobile goal target is corrected if it is above the maximum
	if(liftMGTarget > 1000)
		liftMGTarget = 1000;
	//The mobile goal target is corrected if it is below the minimum
	else if(liftMGTarget < 0)
		liftMGTarget = 0;

	//Finds the error mutplied by the p-value of the mobile goal lift
	int liftMGError = P_LIFT_MG * (thousandthsToPot(LIFT_MG, liftMGTarget) - SensorValue[mgPot]);

	//The mobile goal lift only p-tunes if the error is above the tolerance
	motor[lLiftMG] = motor[rLiftMG] = (abs(liftMGError) >= LIFT_MG_TOL) ? liftMGError : 0;
}

/* SEE void pTuneMGLift(int liftMGTarget)
*  The equivalent of the above function, but the target is passed by
*  reference rather than by value. This version of the function is
*  used during driver mode in conjunction with a local variable */
void pTuneMGLift(int* liftMGTarget) {
	if(*liftMGTarget > 1000)
		*liftMGTarget = 1000;
	else if(*liftMGTarget < 0)
		*liftMGTarget = 0;

	int liftMGError = P_LIFT_MG * (thousandthsToPot(LIFT_MG, *liftMGTarget) - SensorValue[mgPot]);

	motor[lLiftMG] = motor[rLiftMG] = (abs(liftMGError) >= LIFT_MG_TOL) ? liftMGError : 0;
}

/* P-tunes the lift to a specified lift target, which is a
*  thousandths value along the range of the lift.
*  This version of the function is used during autonomous
*  in conjunction with an array */
void pTuneLift(int liftTarget) {
	if(liftTarget > 1000)
		liftTarget = 1000;
	else if(liftTarget < 0)
		liftTarget = 0;

	int lError = thousandthsToPot(LIFT, liftTarget, left) - SensorValue[lLiftPot];
	int rError = thousandthsToPot(LIFT, liftTarget, right) - SensorValue[rLiftPot];

	int lDrive = P_LIFT * lError;
	int rDrive = P_LIFT * rError;

	motor[lLift] = (abs(lError) >= LIFT_TOL) ? lDrive : 0;
	motor[rLift] = (abs(rError) >= LIFT_TOL) ? rDrive : 0;
}

/* PID version of the previous function that is used for user control
*  and is passed by reference than by value.
*  This function is used during driver mode in conjunction with a
*  local variable */
void pidTuneLift(int* liftTarget) {
	if(*liftTarget > 1000)
		*liftTarget = 1000;
	else if(*liftTarget < 0)
		*liftTarget = 0;

	//Sets up static integers to keep track of the integral and previous error
	static int lIntegral = 0;
	static int rIntegral = 0;
	static int lPrevError = 0;
	static int rPrevError = 0;

	//Finds the error between the target and the actual value
	int lError = thousandthsToPot(LIFT, *liftTarget, left) - SensorValue[lLiftPot];
	int rError = thousandthsToPot(LIFT, *liftTarget, right) - SensorValue[rLiftPot];
	//Continuously adds the error to the integral count
	lIntegral += lError;
	rIntegral += rError;
	//Keeps track of the difference between the error and the previous error
	int lDerivative = lError - lPrevError;
	int rDerivative = rError - rPrevError;
	//Resets the previous error
	if(!(time1(T2) % 1)) {
		lPrevError = lError;
		rPrevError = rError;
	}

	//Sets the drive values equal to their respective variable multiplied by the tuning value
	int lDrive = (Kp_LIFT * lError) + (Ki_LIFT * lIntegral) + (Kd_LIFT * lDerivative);
	int rDrive = (Kp_LIFT * rError) + (Ki_LIFT * rIntegral) + (Kd_LIFT * rDerivative);

	//Resets the integral if the drive isn't PID tuning
	if(abs(lError) < LIFT_TOL) {
		lIntegral = 0;
	}
	if(abs(rError) < LIFT_TOL) {
		rIntegral = 0;
	}

	//Debugging graphs used to tune the lift
	datalogAddValueWithTimeStamp(0, lError);
	datalogAddValueWithTimeStamp(1, lDrive);
	datalogAddValueWithTimeStamp(2, Kp_LIFT * lError);
	datalogAddValueWithTimeStamp(3, Kd_LIFT * lDerivative);
	datalogAddValueWithTimeStamp(4, Ki_LIFT * lIntegral);
	datalogAddValueWithTimeStamp(5, *liftTarget);
	datalogAddValueWithTimeStamp(6, potToThousandths(LIFT));

	//Doesn't move the motors if they are too small or it's within the tolerance to reduce motor whine
	motor[lLift] = lDrive;
	motor[rLift] = rDrive;
}

/* The robot drives a set distance in encoder ticks, given by
*  enTarget. It uses a formula to drive at a speed scaled to
*  the difference between the current displacement and the
*  final displacement.  It then drives backwards to counteract
*  any additional drift.  It p-tunes while doing so */
void waitDistance(const int* const targets, int enTarget) {
	SensorValue[rightEn] = 0;		//Encoders zeroed
	SensorValue[leftEn] = 0;
	clearTimer(T1);							//Timer is cleared to make it give up if it takes too long

	int drive = 0;							//Variable for storing the speed the drive should travel at

	int a = 18;									//Variable that reduces drift when increased but also lowers speed

	/* The robot uses a formula to scale speed to position if
	*  the velocity would be within the threshold to start
	*  driving, but otherwise sets the speed equal to the
	*  minimum threshold otherwise */
	while(abs(SensorValue[leftEn]) < abs(enTarget) && time1[T1] < GIVE_UP_TIME) {
		drive = sgn(enTarget) * (a * log(-abs(SensorValue[leftEn]) + abs(enTarget)) + (127 - (a * log(abs(enTarget)))));
		if(sgn(enTarget) > 0 && drive < THRESHOLD) {
			drive = THRESHOLD;
		}
		else if(sgn(enTarget) < 0 && drive > -THRESHOLD) {
			drive = -THRESHOLD;
		}
		motor[bR] = motor[fR] = motor[bL] = motor[fL] = drive;
		pTuneMGLift(targets[LIFT_MG]);		//P-tunes the claw and the lifts while driving
		pTuneLift(targets[LIFT]);
	}

	//Motors drive backward briefly in order to counteract additional drift
	motor[bR] = motor[fR] = motor[bL] = motor[fL] = -sgn(enTarget) * THRESHOLD;
	wait1Msec(110);
	motor[bR] = motor[fR] = motor[bL] = motor[fL] = 0;
}

/* A function used in autonomous that tells the robot to rotate a
*  certain amount in tenths of a degree, using the VEX gyro */
void waitRotate(const int* const targets, int degrees10) {
	//Multiplies the limit switch for the fieldside by the degrees, so that it is on the left side if the toggle variable is false
	degrees10 *= ((fieldSideToggleState) ? 1 : -1);
	SensorValue[yaw] = 0;				//Encoders zeroed
	clearTimer(T1);							//Timer is cleared to make it give up if it takes too long

	int drive = 0;							//Variable that contains the drive speed

	int a = 15;									//The intensity of the drive functoin

	/* Enacts the rotation to a set tenths of a degree (degrees10)
	*  while tuning both lifts. The rotation speed is tuned to
	*  decrease on a slope from 127 to the treshold. If it is past
	*  the threshold, it is set equal to the treshold, but with each
	*  side rotating in a different direction */
	if(degrees10 > 0) {
		while(SensorValue[yaw] < degrees10 && time1(T1) < GIVE_UP_TIME) {
			drive = sgn(degrees10) * (a * log(-abs(SensorValue[yaw]) + abs(degrees10)) + (90 - (a * log(abs(degrees10)))));
			if(abs(drive) > 90) {
				drive = sgn(degrees10) * 90;
			}
			else if(sgn(degrees10) > 0 && drive < THRESHOLD) {
				drive = THRESHOLD;
			}
			else if(sgn(degrees10) < 0 && drive > -THRESHOLD) {
				drive = -THRESHOLD;
			}
			motor[bR] = motor[fR] = drive;		//The right side moves forwards
			motor[bL] = motor[fL] = -drive;		//The left side moves backwards
			pTuneMGLift(targets[LIFT_MG]);		//P-tunes the claws and the lift while rotating
			pTuneLift(targets[LIFT]);
		}
	}
	else {
		while(SensorValue[yaw] > degrees10) {
			drive = sgn(degrees10) * (a * log(-abs(SensorValue[yaw]) + abs(degrees10)) + (90 - (a * log(abs(degrees10)))));
			if(abs(drive) > 90) {
				drive = sgn(degrees10) * 90;
			}
			else if(sgn(degrees10) > 0 && drive < THRESHOLD) {
				drive = THRESHOLD;
			}
			else if(sgn(degrees10) < 0 && drive > -THRESHOLD) {
				drive = -THRESHOLD;
			}
			motor[bR] = motor[fR] = drive;		//The right side moves forwards
			motor[bL] = motor[fL] = -drive;		//The left side moves backwards
			pTuneMGLift(targets[LIFT_MG]);		//P-tunes the claws and the lift while rotating
			pTuneLift(targets[LIFT]);
		}
	}
	//Turns off the drive motors when the rotation is complete
	motor[bR] = motor[fR] = -sgn(degrees10) * THRESHOLD;
	motor[bL] = motor[fL] = sgn(degrees10) * THRESHOLD;
	wait1Msec(110);
	motor[bR]  = motor[fR] = motor[bL] = motor[fL] = 0;
}

/* A function used in autonomous that tells the robot to move in a
*  curved path to a new coordinate that's outTargetX feet away
*  horizontally and outTargetY feet away vertically and the plane
*  is oriented depending on the rotation of the robot. It also has
*  the option to move backwards in a curved motion. The first part
*  of this function calculates the values that it will use and the
*  second part implements them */
void waitDistanceCurve(const int* const targets, int outTargetX, int outTargetY, bool backwards = false) {
	//Sets up a variable in so that it can easily flip the direction if commanded to go backwards
	int direction = (backwards) ? -1 : 1;

	//Sets a new location depending on if the robot is supposed to go left or right
	int location = sgn(outTargetX) * WHEEL_TO_CENTER;

	//Sets up targets for the wheels on the inner side of the curve and gives them default values
	int inTargetX = 0;
	int inTargetY = outTargetY;

	/* Sets up a variable for the portion of the circle being
	*  calculated between the two points. To calculate it, the
	*  distance formula, arcsine, and the fact that all angles in
	*  a triangle add up to 180 are used. This also makes sure
	*  that the target coordinates aren't equal to values that
	*  would result in the function dividing by zero. If it's
	*  ordered to go backwards, the input value of outTargetY is
	*  flipped so that it still calculates it as if it were going
	*  forward */
	float theta = (outTargetX == - 2 * location && !outTargetY) ? 0 :
	180 - 2 * radiansToDegrees(asin((direction * outTargetY) / sqrt((pow(outTargetX + 2 * location, 2)) + (pow(outTargetY, 2)))));

	/* Calculates and sets the inner wheel targets using
	*  trigonometry. The value also depends on the direction
	*  that the robot is traveling */
	if(outTargetX > 0) {
		inTargetX = outTargetX + 2 * location * cosDegrees(theta);
		inTargetY = outTargetY - 2 * location * sinDegrees(theta);
	}
	else if(outTargetX < 0) {
		inTargetX = outTargetX + 2 * location * cosDegrees(theta);
		inTargetY = outTargetY + 2 * location * sinDegrees(theta);
	}

	/* Calculates the radios of the circle each path finds
	*  using the law of sines and makes sure that that it
	*  doesn't divide by zero */
	int outRadius = (theta) ? abs(outTargetX / (sin(theta))) : 0;
	int inRadius = (theta) ? abs(inTargetX / (sin(theta))) : 0;

	/* Calculates the distance it has to travels using the
	*  equation for the circumference of the circle dividing
	*  it by the potion of the circle being traveled in order
	*  to give each encoder a target value. It also converts
	*  the answer into encoder ticks so that it won't round the
	*  variable very much considering that it's an integer */
	int outDistance = 2 * PI * outRadius * (theta / 360);
	int inDistance = 2 * PI * inRadius * (theta / 360);

	/* Calculates the ratio between the target distances for the
	*  encoders so that it can multiply the inner motors by this
	*  speed. This will make sure that each side takes the same
	*  amount of time to cover their target distances. It also
	*  makes sure that it doesn't divide by zero */
	int speedRatio = (outDistance) ? inDistance / outDistance : 0;

	SensorValue[rightEn] = 0;	//Encoders zeroed
	SensorValue[leftEn] = 0;
	clearTimer(T1);						//Timer is cleared to make it give up if it takes too long

	int lDrive = 0;						//Variables for storing the speed the drives should travel at
	int rDrive = 0;

	int a = 18;								//Variable that reduces drift when increased but also lowers speed

	/* If the target involves turning right, the left encoder's
	*  target is the outer distnace and the inner encoder's target
	*  is the inner distance. The values are multiplied by the
	*  direction so that they flip if the robot is ordered to move
	*  backwards. It uses the same logarithmic tuner as the
	*  previous two functions and sets the motors equal to the
	*  threshold if the fall below the threshold. It then multiplies
	*  the right motor speed by the speed ratio since that's on the
	*  inner side so it'll have to move slower. It also p-tunes both
	*  lifts while moving. */
	if(outTargetX > 0) {
		while(SensorValue[leftEn] < outDistance && SensorValue[rightEn] < inDistance && time1[T1] < GIVE_UP_TIME) {
			lDrive = direction * a * log(-abs(SensorValue[leftEn]) + outDistance) + (127 - (a * log(outDistance)));
			rDrive = direction * a * log(-abs(SensorValue[rightEn]) + inDistance) + (127 - (a * log(inDistance)));
			if(lDrive < THRESHOLD)
				lDrive = direction * THRESHOLD;
			else if(rDrive < THRESHOLD)
				rDrive = direction * THRESHOLD;
			motor[bR] = motor[fR] = speedRatio * rDrive;
			motor[bL] = motor[fL] = lDrive;
			pTuneMGLift(targets[LIFT_MG]);
			pTuneLift(targets[LIFT]);
		}
	}
	/* If the target involves turning left, the encoder sides are
	*  set to the opposite configuration. This has the same commands
	*  but it accounds for the inner distance being on the left. */
	else if(outTargetX < 0) {
		while(SensorValue[leftEn] < inDistance && SensorValue[rightEn] < outDistance && time1[T1] < 5000) {
			lDrive = direction * a * log(-abs(SensorValue[leftEn]) + inDistance) + (127 - (a * log(inDistance)));
			rDrive = direction * a * log(-abs(SensorValue[rightEn]) + outDistance) + (127 - (a * log(outDistance)));
			if(lDrive < THRESHOLD)
				lDrive = direction * THRESHOLD;
			else if(rDrive < THRESHOLD)
				rDrive = direction * THRESHOLD;
			motor[bR] = motor[fR] = rDrive;
			motor[bL] = motor[fL] = speedRatio * lDrive;
			pTuneMGLift(targets[LIFT_MG]);
			pTuneLift(targets[LIFT]);
		}
	}

	//Motors drive backward briefly in order to counteract additional drift
	motor[bR] = motor[fR] = motor[bL] = motor[fL] = -direction * THRESHOLD;
	wait1Msec(110);
	motor[bR] = motor[fR] = motor[bL] = motor[fL] = 0;
}

/* A somewhat general function used in that changes the
*  contents of the current target values for the lifts and claw,
*  and then pTunes both the lifts and claw with their new target
*  values */
void waitActions(int* targets, int liftMGTarget, int clawTarget, int liftTarget) {
	//Assigns the contents of targets to the new lift and claw target values
	targets[CLAW] = clawTarget;
	targets[LIFT_MG] = liftMGTarget;
	targets[LIFT] = liftTarget;
	//P-tunes the lifts and the claw
	setClaw(targets[CLAW]);
	pTuneMGLift(targets[LIFT_MG]);
	pTuneLift(targets[LIFT]);
}

/* Sets targets equal to the new values, then continues to test to see
*  if the claw is within the range specified by tolerance, which is
*  defined by the user or set equal to the default tolerance */
void testClaw(int* targets, int liftMGTarget, int clawTarget, int liftTarget, int accuracy = CLAW_ACC_TOL) {
	do {
		waitActions(targets, liftMGTarget, clawTarget, liftTarget);
	} while(potToThousandths(CLAW) < clawTarget - accuracy || potToThousandths(CLAW) > clawTarget + accuracy);
}

/* Specific function for p-tuning just the claw */
void setClaw(int* targets, int clawTarget, int accuracy = CLAW_ACC_TOL) {
	testClaw(targets, targets[LIFT_MG], clawTarget, targets[LIFT], accuracy);
}

/* Sets targets equal to the new values, then continues to test to see
*  if the mobile goal lift is within the range specified by tolerance,
*  which is defined by the user or set equal to the default
*  tolerance */
void testMGLift(int* targets, int liftMGTarget, int clawTarget, int liftTarget, int accuracy = LIFT_MG_ACC_TOL) {
	do {
		waitActions(targets, liftMGTarget, clawTarget, liftTarget);
	} while(potToThousandths(LIFT_MG) < liftMGTarget - accuracy || potToThousandths(LIFT_MG) > liftMGTarget + accuracy);
}

/* Specific function for p-tuning just the mobile goal lift */
void setMGLift(int* targets, int liftMGTarget, int accuracy = LIFT_MG_ACC_TOL) {
	testMGLift(targets, liftMGTarget, targets[CLAW], targets[LIFT], accuracy);
}

/* Sets targets equal to the new values, then continues to test to see
*  if the lift is within the range specified by tolerance, which is
*  defined by the user or set equal to the default tolerance */
void testLift(int* targets, int liftMGTarget, int clawTarget, int liftTarget, int accuracy = LIFT_ACC_TOL) {
	do {
		waitActions(targets, liftMGTarget, clawTarget, liftTarget);
	} while(potToThousandths(LIFT) < liftTarget - accuracy || potToThousandths(LIFT) > liftTarget + accuracy);
}

/* Specific function for p-tuning just the lift */
void setLift(int* targets, int liftTarget, int accuracy = LIFT_ACC_TOL) {
	testLift(targets, targets[LIFT_MG], targets[CLAW], liftTarget, accuracy);
}

/* Function for auto stacking a cone */
void stackCone(int* targets) {
	int currentStackHeight = stackCount * STACK_HEIGHT;			//Create a variable for the current height of the cone stack

	setLift(targets, BASE_HEIGHT + 400 + currentStackHeight);	//Raises the lift to the right height
	setClaw(targets, 0);																			//Rotates the claw upwards
	wait1Msec(200);
	setLift(targets, BASE_HEIGHT + currentStackHeight);				//Lowers the cone onto the mobile goal
	wait1Msec(400);
	setClaw(targets, 1000);																		//Rotates the claw forwards

	playTone(1050, 50);																				//Plays a tone when finished
	stackCount++;
}

/* Eliminates motor whine on the drive during user control */
int axesFix(int remote) {
	if(abs(remote) >= THRESHOLD) 		//Returns 0 if the value does not pass the TRESHOLD constant
		return remote;
	else
		return 0;
}

void LCDAutonSelection()
{
	//Clear LCD and turn on backlight
	clearLCDLine(0);
	clearLCDLine(1);
	bLCDBacklight = true;

	//Displays default choices
	displayLCDString(0, 0, "Auton Settings:");
	displayLCDString(1, 0, "L     NoSk    ON");

	while(bIfiRobotDisabled) {
		//Check for the left button being pressed if the button isn't already pressed
		if((nLCDButtons & leftBtnVEX) && !(fieldSidePressed)) {
			fieldSideToggleState = !(fieldSideToggleState);	//Change the toggle state
			fieldSidePressed = true;												//Note that the button is pressed
		}
		//If the left button isn't pressed
		else if (!(nLCDButtons & leftBtnVEX)) {
			fieldSidePressed = false;													//Note that the button is not pressed
		}

		//Same toggle switch with the skills button
		if((nLCDButtons & centerBtnVEX) && !(skillsPressed)) {
			skillsToggleState = !(skillsToggleState);
			skillsPressed = true;
		}
		else if (!(nLCDButtons & centerBtnVEX)) {
			skillsPressed = false;
		}

		//same toggle switch for whether or not the auton will activate
		if((nLCDButtons & rightBtnVEX) && !(autonPressed)) {
			autonToggleState = !(autonToggleState);
			autonPressed = true;
		}
		else if (!(nLCDButtons & rightBtnVEX)) {
			autonPressed = false;
		}

		//Print various messages depending on the button state
		if(fieldSideToggleState)
			displayLCDString(1, 0, "R");
		else if(!(fieldSideToggleState))
			displayLCDString(1, 0, "L");
		if(!(skillsToggleState))
			displayLCDString(1, 6, "NoSk");
		else if(skillsToggleState)
			displayLCDString(1, 6, "Sk  ");
		if(autonToggleState)
			displayLCDString(1, 13, "ON ");
		else if(!(autonToggleState))
			displayLCDString(1, 13, "OFF");
	}
}



/******************************************************************
/*
/*											 TASKS
/*
*******************************************************************/



//Task for displaying the battery on the LCD Screen
task displayBattery()
{
	bool toggleSwitch = false;					//Toggle switch variable
	string mainBattery, backupBattery;	//Setup two strings
	while(1) {
		//Toggle switch code for turning on and off
		if(nLCDButtons) {
			toggleSwitch = !toggleSwitch;
			wait1Msec(500);
		}
		if(toggleSwitch) {
			bLCDBacklight = true;     		 	//Turn on LCD Backlight
			clearLCDLine(0);         		   	//Clear line 1 of the LCD
			clearLCDLine(1);          		 	//Clear line 2 of the LCD

			//Display the Primary Robot battery voltage
			displayLCDString(0, 0, "Primary: ");
			sprintf(mainBattery, "%1.2f%c", nImmediateBatteryLevel/1000.0,'V'); //Build the value to be displayed
			displayNextLCDString(mainBattery);

			//Display the Backup battery voltage
			displayLCDString(1, 0, "Backup: ");
			sprintf(backupBattery, "%1.2f%c", BackupBatteryLevel/1000.0, 'V');	//Build the value to be displayed
			displayNextLCDString(backupBattery);

			//Short delay for the LCD refresh rate
			wait1Msec(100);
		}
		else {
			bLCDBacklight = false;     		 	//Turn off LCD Backlight
			clearLCDLine(0);         		   	//Clear line 1 of the LCD
			clearLCDLine(1);          		 	//Clear line 2 of the LCD
		}
	}
}

//Task for calibrating the gyro
task calibrateGyro()
{
	SensorType[yaw] = sensorNone;	//Resets the gyroscope
	wait1Msec(1100);							//Provides time for calibration
	SensorType[yaw] = sensorGyro;	//Reassigns the yaw gyroscope's sensor type
	wait1Msec(1100);							//Waits for the gyro to calibrate

	SensorValue[rightEn] = 0;			//Zeroes the right encoder
	SensorValue[leftEn] = 0;			//Zeroes the left encoder
	playTone(1200, 50);						//Plays a tone when calibration is finished to alert the operator
}

//Task for the drive during usercontrol
task drive() {
	while(1) {
		//Drive input:
		motor[fR] = motor[bR] = axesFix(vexRT[Ch2]);			//Sets the right motors equal to channel 2
		motor[fL] = motor[bL] = axesFix(vexRT[Ch3]);			//Sets the left motors equal to channel 3
	}
}



/******************************************************************
/*
/*											 AUTONOMOUS CODE
/*
*******************************************************************/



void pre_auton()
{
	bStopTasksBetweenModes = true;

	//Calibrates the gyro and turns on the LCD
	startTask(calibrateGyro);
	LCDAutonSelection();
}

task autonomous()
{
	/* targets is an array of integers that stores the target
	*  values for the mglift, claw, rotation, and lift */
	int targets[N_TARGETS] = {potToThousandths(CLAW), potToThousandths(LIFT_MG), potToThousandths(LIFT)};

	//Only starts the autonomous if the togglestate is true
	if(autonToggleState) {
		// Skills Autonomous
		if(skillsToggleState) {
			setLift(targets, 500, 150);
			setMGLift(targets, 1000);
			waitDistance(targets, 1300);
			setMGLift(targets, 0);		// pick up first goal
			setLift(targets, 25);
			waitDistance(targets, -1100);
			waitRotate(targets, -450);
			waitDistance(targets, -550);
			waitRotate(targets, -850);
			waitDistance(targets, 250);
			setClaw(targets, 1000);
			setLift(targets, 400, 100);
			setClaw(targets, 0);
			setMGLift(targets, 1000);		// pick up second goal
			// setLift(targets, 400, 150);
			waitDistance(targets, -200);
			wait1Msec(500);
			waitRotate(targets, 1860);
			waitDistance(targets, 425);
			setMGLift(targets, 0);
			setLift(targets, 50);
			waitDistance(targets, -500);
			waitRotate(targets, 875);
		}

		//Regular Autonomous
		else {
		/*	setLift(targets, 500, 150);
			setMGLift(targets, 1000);
			waitDistance(targets, 1500);
			setMGLift(targets, 0);
			setLift(targets, 0, 100);
			waitDistance(targets, -1300);
			waitRotate(targets, 450);
			waitDistance(targets, -600);
			waitRotate(targets, -500);
			setClaw(targets, 1000);
			setLift(targets, 300);
			setClaw(targets, 0);
			motor[fL] = motor[bL] = motor[fR] = motor[bR] = 127;
			wait1Msec(1300);
			motor[fL] = motor[bL] = 0;
			wait1Msec(300);
			motor[fR] = motor[bR] = 0;
			setLift(targets, 600, 100);
			setMGLift(targets, 1000);
			motor[fL] = motor[bL] = motor[fR] = motor[bR] = -127;
			wait1Msec(1000);
			motor[fL] = motor[bL] = motor[fR] = motor[bR] = 0;
			setMGLift(targets, 0);
			setLift(targets, 0); */

			setLift(targets, 500, 150);
			setMGLift(targets, 1000);
			waitDistance(targets, 1300);
			setMGLift(targets, 0);
			setLift(targets, 25);
			waitDistance(targets, -1100);
			waitRotate(targets, -450);
			waitDistance(targets, -550);
			waitRotate(targets, -850);
			waitDistance(targets, 250);
			setClaw(targets, 1000);
			setLift(targets, 400, 100);
			setClaw(targets, 0);
			setMGLift(targets, 1000);
			waitDistance(targets, -600);
		}
	}
}



/******************************************************************
/*
/*											 USER CONTROL
/*
*******************************************************************/



task usercontrol()
{
	//	startTask(manageMusic);		//Plays randomly-chosen music in the last seconds of a match
	startTask(displayBattery);		//Displays the battery voltage
	startTask(drive);							//Starts the drive task

	clearTimer(T2);								//Clears the timer for the PID

	//Sets the targets equal to the current positions
	int liftTarget = potToThousandths(LIFT);
	int mgLiftTarget = potToThousandths(LIFT_MG);

	int currentStackHeight = stackCount * STACK_HEIGHT; //Creates a variable for the height to stack at

	bool incrementPressed = false;		//Variable for incrementing the stack count

	while (1)
	{
		//Ch2					=		Right drive
		//Ch3					=		Left drive
		//5U and 5D		=		Lift
		//6U and 6D		=		Claw
		//7L					=		Mobile goal up
		//7D					=		Mobile goal down
		//8L					=		Lift force up
		//8U					=		Stack cone
		//8D					=		Lift force down
		//8R					=		Reset count

		//Give up function
		if(vexRT[Btn5U] && vexRT[Btn5D] && vexRT[Btn8D]) {
			allMotorsOff();
			liftTarget = potToThousandths(LIFT);
			mgLiftTarget = potToThousandths(LIFT_MG);
		}

		//Claw input:
		if(vexRT[Btn6U]) {
			//Sets the motors equal to 127 if the potentiometer is greater than the minium
			motor[lClaw] = motor[rClaw] = (potToThousandths(CLAW) >= CLAW_TOL) ? 127 : 0;
		}
		else if(vexRT[Btn6D]) {
			//Sets the motors equal to -127 if the potentiometer is less than the maximum
			motor[lClaw] = motor[rClaw] = (potToThousandths(CLAW) <= 1000 - CLAW_TOL) ? -127 : 0;
		}
		else
			motor[lClaw] = motor[rClaw] = 0;

		//Lift input:
		if(vexRT[Btn8D]) {
			//Overrides the main lift buttons and goes full speed downwards
			motor[lLift] = motor[rLift] = -127;
			liftTarget = potToThousandths(LIFT);
		}
		else if(vexRT[Btn8L]) {
			//Moves the lift to a height depending on the current stack
			liftTarget = (BASE_HEIGHT + currentStackHeight + 200 <= 1000) ? BASE_HEIGHT + currentStackHeight + 200 : 1000;
		}
		else if((vexRT[Btn5U] || vexRT[Btn5D]) && !vexRT[Btn8D]) {
			//5U and 5D shoulder buttons increment and decrement the lift target
			liftTarget += (vexRT[Btn5U] - vexRT[Btn5D]);
		}
		if(!vexRT[Btn8D])
			//Only PID tunes if the the override button isn't pressed
			pidTuneLift(&liftTarget);					//PID tunes the lift

		//Mobile goal lift input:
		if(vexRT[Btn7L] || vexRT[Btn7D])		//Raises the lift if 7L or 7D is pressed
			mgLiftTarget -= 3 * (vexRT[Btn7D] - vexRT[Btn7L]);

		pTuneMGLift(&mgLiftTarget);

		/* These buttons increment the internal stackcount and
		*  have the speaker play tunes to indicate what the
		*  stack count is. */
		if(vexRT[Btn7U] && !incrementPressed) {
			stackCount++;
			incrementPressed = true;
			//Plays a tone as many times as the stack count
			for(int i = 0; i < stackCount; i++) {
				playTone(800, 100);
				wait1Msec(200);
			}
		}
		else if(vexRT[Btn7R] && !incrementPressed) {
			if(stackCount > 0)
				stackCount--;
			incrementPressed = true;
			for(int i = 0; i < stackCount; i++) {
				playTone(400, 100);
				wait1Msec(200);
			}
		}
		else if (!(vexRT[Btn7U]) && !(vexRT[Btn7R])) {
			incrementPressed = false;
		}
		/* Stack function and stack reset
		*  See void stackCone(int* targets) */
		if(vexRT[Btn8U]) {
			currentStackHeight = stackCount * STACK_HEIGHT; //Creates a variable for the height to stack at

			/* Series of commands to get the lift to go up, claw to rotate
			*  inward, lift to go down, and claw to rotate outward again */

			//ROTATES CLAW UP
			clearTimer(T1);
			while((potToThousandths(CLAW) > 0) && time1[T1] < GIVE_UP_TIME) {
				motor[lClaw] = motor[rClaw] = 127;
			}
			motor[lClaw] = motor[rClaw] = 0;
			wait1Msec(500);

			//LOWERS LIFT
			clearTimer(T1);
			liftTarget = BASE_HEIGHT + currentStackHeight;
			while((potToThousandths(LIFT) > liftTarget) && time1[T1] < GIVE_UP_TIME) {
				pTuneLift(liftTarget);
			}
			wait1Msec(400);

			//ROTATES CLAW DOWN
			clearTimer(T1);
			while((potToThousandths(CLAW) < 1000) && time1[T1] < GIVE_UP_TIME) {
				motor[lClaw] = motor[rClaw] = -127;
				motor[lLift] = motor[rLift] = 50;
			}
			motor[lLift] = motor[rLift] = 0;
			motor[lClaw] = motor[rClaw] = 0;

			liftTarget = potToThousandths(LIFT);	//Resets lift target
			stackCount++;												//Increments stack count
		}
		else if(vexRT[Btn8R]) {		//Resets the stack count if 8L is pressed
			stackCount = 0;
			playTone(525, 1000);
		}
	}
}
